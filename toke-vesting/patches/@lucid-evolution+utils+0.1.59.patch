diff --git a/node_modules/@lucid-evolution/utils/index.cjs b/node_modules/@lucid-evolution/utils/index.cjs
new file mode 100644
index 0000000..a4c2530
--- /dev/null
+++ b/node_modules/@lucid-evolution/utils/index.cjs
@@ -0,0 +1,1736 @@
+"use strict";
+var __create = Object.create;
+var __defProp = Object.defineProperty;
+var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
+var __getOwnPropNames = Object.getOwnPropertyNames;
+var __getProtoOf = Object.getPrototypeOf;
+var __hasOwnProp = Object.prototype.hasOwnProperty;
+var __export = (target, all) => {
+  for (var name in all)
+    __defProp(target, name, { get: all[name], enumerable: true });
+};
+var __copyProps = (to, from, except, desc) => {
+  if (from && typeof from === "object" || typeof from === "function") {
+    for (let key of __getOwnPropNames(from))
+      if (!__hasOwnProp.call(to, key) && key !== except)
+        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
+  }
+  return to;
+};
+var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
+  // If the importer is in node compatibility mode or this is not an ESM
+  // file that has been converted to a CommonJS file using a Babel-
+  // compatible transform (i.e. "__esModule" has not been set), then set
+  // "default" to the CommonJS "module.exports" for node compatibility.
+  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
+  mod
+));
+var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
+
+// src/index.ts
+var src_exports = {};
+__export(src_exports, {
+  CBOREncodingLevel: () => CBOREncodingLevel,
+  PROTOCOL_PARAMETERS_DEFAULT: () => PROTOCOL_PARAMETERS_DEFAULT,
+  addAssets: () => addAssets,
+  addressFromHexOrBech32: () => addressFromHexOrBech32,
+  applyDoubleCborEncoding: () => applyDoubleCborEncoding,
+  applyParamsToScript: () => applyParamsToScript,
+  applySingleCborEncoding: () => applySingleCborEncoding,
+  assetsToValue: () => assetsToValue,
+  calculateMinLovelaceFromUTxO: () => calculateMinLovelaceFromUTxO,
+  coreToOutRef: () => coreToOutRef,
+  coreToTxOutput: () => coreToTxOutput,
+  coreToUtxo: () => coreToUtxo,
+  coresToOutRefs: () => coresToOutRefs,
+  coresToTxOutputs: () => coresToTxOutputs,
+  coresToUtxos: () => coresToUtxos,
+  createCostModels: () => createCostModels,
+  credentialToAddress: () => credentialToAddress,
+  credentialToRewardAddress: () => credentialToRewardAddress,
+  datumJsonToCbor: () => datumJsonToCbor,
+  datumToHash: () => datumToHash,
+  fromCMLRedeemerTag: () => fromCMLRedeemerTag,
+  fromLabel: () => fromLabel,
+  fromScriptRef: () => fromScriptRef,
+  fromUnit: () => fromUnit,
+  generatePrivateKey: () => generatePrivateKey,
+  generateSeedPhrase: () => generateSeedPhrase,
+  getAddressDetails: () => getAddressDetails,
+  getInputIndices: () => getInputIndices,
+  getUniqueTokenName: () => getUniqueTokenName,
+  isEqualUTxO: () => isEqualUTxO,
+  keyHashToCredential: () => keyHashToCredential,
+  mintingPolicyToId: () => mintingPolicyToId,
+  networkToId: () => networkToId,
+  parseCMLNative: () => parseCMLNative,
+  paymentCredentialOf: () => paymentCredentialOf,
+  scriptFromCMLNative: () => scriptFromCMLNative,
+  scriptFromNative: () => scriptFromNative,
+  scriptHashToCredential: () => scriptHashToCredential,
+  selectUTxOs: () => selectUTxOs,
+  slotToUnixTime: () => slotToUnixTime,
+  sortCanonical: () => sortCanonical,
+  sortUTxOs: () => sortUTxOs,
+  stakeCredentialOf: () => stakeCredentialOf,
+  stringify: () => stringify,
+  toCMLNativeScript: () => toCMLNativeScript,
+  toCMLRedeemerTag: () => toCMLRedeemerTag,
+  toLabel: () => toLabel,
+  toPublicKey: () => toPublicKey,
+  toScriptRef: () => toScriptRef,
+  toUnit: () => toUnit,
+  unixTimeToSlot: () => unixTimeToSlot,
+  utxoToCore: () => utxoToCore,
+  utxoToTransactionInput: () => utxoToTransactionInput,
+  utxoToTransactionOutput: () => utxoToTransactionOutput,
+  utxosToCores: () => utxosToCores,
+  validatorToAddress: () => validatorToAddress,
+  validatorToRewardAddress: () => validatorToRewardAddress,
+  validatorToScriptHash: () => validatorToScriptHash,
+  valueToAssets: () => valueToAssets
+});
+module.exports = __toCommonJS(src_exports);
+
+// src/native.ts
+var S = __toESM(require("@effect/schema/Schema"), 1);
+
+// src/core.ts
+var CML = __toESM(require("@anastasia-labs/cardano-multiplatform-lib-nodejs"), 1);
+
+// src/native.ts
+var toCMLNativeScript = (native) => {
+  switch (native.type) {
+    case "sig":
+      return CML.NativeScript.new_script_pubkey(
+        CML.Ed25519KeyHash.from_hex(native.keyHash)
+      );
+    case "before":
+      return CML.NativeScript.new_script_invalid_hereafter(BigInt(native.slot));
+    case "after":
+      return CML.NativeScript.new_script_invalid_before(BigInt(native.slot));
+    case "all": {
+      const nativeList = CML.NativeScriptList.new();
+      native.scripts.map((script) => nativeList.add(toCMLNativeScript(script)));
+      return CML.NativeScript.new_script_all(nativeList);
+    }
+    case "any": {
+      const nativeList = CML.NativeScriptList.new();
+      native.scripts.map((script) => nativeList.add(toCMLNativeScript(script)));
+      return CML.NativeScript.new_script_any(nativeList);
+    }
+    case "atLeast": {
+      const nativeList = CML.NativeScriptList.new();
+      native.scripts.map((script) => nativeList.add(toCMLNativeScript(script)));
+      return CML.NativeScript.new_script_n_of_k(
+        BigInt(native.required),
+        nativeList
+      );
+    }
+  }
+};
+var scriptFromNative = (native) => {
+  return {
+    type: "Native",
+    script: toCMLNativeScript(native).to_cbor_hex()
+  };
+};
+var CMLNativeSchema = S.Union(
+  S.Struct({
+    ScriptPubkey: S.Struct({
+      ed25519_key_hash: S.String
+    })
+  }),
+  S.Struct({
+    ScriptInvalidBefore: S.Struct({
+      before: S.Number
+    })
+  }),
+  S.Struct({
+    ScriptInvalidHereafter: S.Struct({
+      after: S.Number
+    })
+  }),
+  S.Struct({
+    ScriptAll: S.Struct({
+      native_scripts: S.Array(S.suspend(() => CMLNativeSchema))
+    })
+  }),
+  S.Struct({
+    ScriptAny: S.Struct({
+      native_scripts: S.Array(S.suspend(() => CMLNativeSchema))
+    })
+  }),
+  S.Struct({
+    ScriptNOfK: S.Struct({
+      n: S.Number,
+      native_scripts: S.Array(S.suspend(() => CMLNativeSchema))
+    })
+  })
+);
+var parseCMLNative = S.decodeUnknownSync(CMLNativeSchema);
+var scriptFromCMLNative = (cmlNative) => {
+  return {
+    type: "Native",
+    script: CML.NativeScript.from_json(JSON.stringify(cmlNative)).to_cbor_hex()
+  };
+};
+
+// src/network.ts
+function networkToId(network) {
+  switch (network) {
+    case "Preview":
+      return 0;
+    case "Preprod":
+      return 0;
+    case "Custom":
+      return 0;
+    case "Mainnet":
+      return 1;
+    default:
+      throw new Error("Network not found");
+  }
+}
+
+// src/cbor.ts
+var import_core_utils = require("@lucid-evolution/core-utils");
+var import_cbor_x = require("cbor-x");
+var applyDoubleCborEncoding = (script) => {
+  try {
+    (0, import_cbor_x.decode)((0, import_cbor_x.decode)((0, import_core_utils.fromHex)(script)));
+    return script;
+  } catch (error) {
+    try {
+      (0, import_cbor_x.decode)((0, import_core_utils.fromHex)(script));
+      return (0, import_core_utils.toHex)(Uint8Array.from((0, import_cbor_x.encode)((0, import_core_utils.fromHex)(script).buffer)));
+    } catch (error2) {
+      return (0, import_core_utils.toHex)(Uint8Array.from((0, import_cbor_x.encode)((0, import_cbor_x.encode)((0, import_core_utils.fromHex)(script).buffer))));
+    }
+  }
+};
+var applySingleCborEncoding = (script) => {
+  try {
+    (0, import_cbor_x.decode)((0, import_cbor_x.decode)((0, import_core_utils.fromHex)(script)));
+    return (0, import_core_utils.toHex)((0, import_cbor_x.decode)((0, import_core_utils.fromHex)(script)));
+  } catch (error) {
+    try {
+      (0, import_cbor_x.decode)((0, import_core_utils.fromHex)(script));
+      return script;
+    } catch (error2) {
+      return (0, import_core_utils.toHex)(Uint8Array.from((0, import_cbor_x.encode)((0, import_core_utils.fromHex)(script).buffer)));
+    }
+  }
+};
+var CBOREncodingLevel = (script) => {
+  try {
+    (0, import_cbor_x.decode)((0, import_cbor_x.decode)((0, import_core_utils.fromHex)(script)));
+    return "double";
+  } catch (error) {
+    try {
+      (0, import_cbor_x.decode)((0, import_core_utils.fromHex)(script));
+      return "single";
+    } catch (error2) {
+      throw new Error("Script is not CBOR-encoded or invalid format.");
+    }
+  }
+};
+function datumJsonToCbor(json) {
+  const convert = (json2) => {
+    if (!isNaN(json2.int)) {
+      const plutusBigInt = CML.BigInteger.from_str(json2.int.toString());
+      return CML.PlutusData.new_integer(plutusBigInt);
+    } else if (json2.bytes || !isNaN(Number(json2.bytes))) {
+      return CML.PlutusData.new_bytes((0, import_core_utils.fromHex)(json2.bytes));
+    } else if (json2.list) {
+      const l = CML.PlutusDataList.new();
+      json2.list.forEach((v) => {
+        l.add(convert(v));
+      });
+      return CML.PlutusData.new_list(l);
+    } else if (json2.map && json2.map.length > 0 && typeof json2.map[0] === "object") {
+      const m = CML.PlutusMap.new();
+      json2.map.forEach(({ k, v }) => {
+        m.set(convert(k), convert(v));
+      });
+      return CML.PlutusData.new_map(m);
+    } else if (json2.map && typeof json2.map === "function") {
+      const l = CML.PlutusDataList.new();
+      Object.values(json2).forEach((value) => {
+        l.add(convert(value));
+      });
+      return CML.PlutusData.new_list(l);
+    } else if (!isNaN(json2.constructor)) {
+      const l = CML.PlutusDataList.new();
+      json2.fields.forEach((v) => {
+        l.add(convert(v));
+      });
+      const bigInt = CML.BigInteger.from_str(
+        json2.constructor.toString()
+      ).as_u64();
+      return CML.PlutusData.new_constr_plutus_data(
+        CML.ConstrPlutusData.new(bigInt, l)
+      );
+    }
+    throw new Error("Unsupported type");
+  };
+  return convert(json).to_cbor_hex();
+}
+
+// src/scripts.ts
+var import_plutus = require("@lucid-evolution/plutus");
+var import_uplc = require("@harmoniclabs/uplc");
+var import_core_utils2 = require("@lucid-evolution/core-utils");
+var import_cbor_x2 = require("cbor-x");
+var import_plutus_data = require("@harmoniclabs/plutus-data");
+function validatorToAddress(network, validator, stakeCredential) {
+  const validatorHash = validatorToScriptHash(validator);
+  if (stakeCredential) {
+    return CML.BaseAddress.new(
+      networkToId(network),
+      CML.Credential.new_script(CML.ScriptHash.from_hex(validatorHash)),
+      stakeCredential.type === "Key" ? CML.Credential.new_pub_key(
+        CML.Ed25519KeyHash.from_hex(stakeCredential.hash)
+      ) : CML.Credential.new_script(
+        CML.ScriptHash.from_hex(stakeCredential.hash)
+      )
+    ).to_address().to_bech32(void 0);
+  } else {
+    return CML.EnterpriseAddress.new(
+      networkToId(network),
+      CML.Credential.new_script(CML.ScriptHash.from_hex(validatorHash))
+    ).to_address().to_bech32(void 0);
+  }
+}
+function validatorToScriptHash(validator) {
+  switch (validator.type) {
+    case "Native":
+      return CML.NativeScript.from_cbor_hex(validator.script).hash().to_hex();
+    case "PlutusV1":
+      return CML.PlutusScript.from_v1(
+        CML.PlutusV1Script.from_cbor_hex(
+          applyDoubleCborEncoding(validator.script)
+        )
+      ).hash().to_hex();
+    case "PlutusV2":
+      return CML.PlutusScript.from_v2(
+        CML.PlutusV2Script.from_cbor_hex(
+          applyDoubleCborEncoding(validator.script)
+        )
+      ).hash().to_hex();
+    case "PlutusV3":
+      return CML.PlutusScript.from_v3(
+        CML.PlutusV3Script.from_cbor_hex(
+          applyDoubleCborEncoding(validator.script)
+        )
+      ).hash().to_hex();
+    default:
+      throw new Error("No variant matched");
+  }
+}
+function toScriptRef(script) {
+  switch (script.type) {
+    case "Native":
+      return CML.Script.new_native(
+        CML.NativeScript.from_cbor_hex(script.script)
+      );
+    case "PlutusV1":
+      return CML.Script.new_plutus_v1(
+        CML.PlutusV1Script.from_cbor_hex(
+          applyDoubleCborEncoding(script.script)
+        )
+      );
+    case "PlutusV2":
+      return CML.Script.new_plutus_v2(
+        CML.PlutusV2Script.from_cbor_hex(
+          applyDoubleCborEncoding(script.script)
+        )
+      );
+    case "PlutusV3":
+      return CML.Script.new_plutus_v3(
+        CML.PlutusV3Script.from_cbor_hex(
+          applyDoubleCborEncoding(script.script)
+        )
+      );
+    default:
+      throw new Error("No variant matched.");
+  }
+}
+function fromScriptRef(scriptRef) {
+  const kind = scriptRef.kind();
+  switch (kind) {
+    case 0:
+      return {
+        type: "Native",
+        script: scriptRef.as_native().to_cbor_hex()
+      };
+    case 1:
+      return {
+        type: "PlutusV1",
+        script: scriptRef.as_plutus_v1().to_cbor_hex()
+      };
+    case 2:
+      return {
+        type: "PlutusV2",
+        script: scriptRef.as_plutus_v2().to_cbor_hex()
+      };
+    case 3:
+      return {
+        type: "PlutusV3",
+        script: scriptRef.as_plutus_v3().to_cbor_hex()
+      };
+    default:
+      throw new Error("No variant matched.");
+  }
+}
+function mintingPolicyToId(mintingPolicy) {
+  return validatorToScriptHash(mintingPolicy);
+}
+function applyParamsToScript(plutusScript, params, type) {
+  const program = (0, import_uplc.parseUPLC)(
+    (0, import_cbor_x2.decode)((0, import_cbor_x2.decode)((0, import_core_utils2.fromHex)(applyDoubleCborEncoding(plutusScript)))),
+    "flat"
+  );
+  const parameters = type ? import_plutus.Data.castTo(params, type) : params;
+  const appliedProgram = parameters.reduce((body, currentParameter) => {
+    const data = import_uplc.UPLCConst.data((0, import_plutus_data.dataFromCbor)(import_plutus.Data.to(currentParameter)));
+    const appliedParameter = new import_uplc.Application(body, data);
+    return appliedParameter;
+  }, program.body);
+  return applyDoubleCborEncoding(
+    (0, import_core_utils2.toHex)(
+      (0, import_uplc.encodeUPLC)(new import_uplc.UPLCProgram(program.version, appliedProgram)).toBuffer().buffer
+    )
+  );
+}
+
+// src/address.ts
+function addressFromHexOrBech32(address) {
+  try {
+    return CML.Address.from_hex(address);
+  } catch (_e) {
+    try {
+      return CML.Address.from_bech32(address);
+    } catch (_e2) {
+      throw new Error("Could not deserialize address.");
+    }
+  }
+}
+function credentialToRewardAddress(network, stakeCredential) {
+  return CML.RewardAddress.new(
+    networkToId(network),
+    stakeCredential.type === "Key" ? CML.Credential.new_pub_key(
+      CML.Ed25519KeyHash.from_hex(stakeCredential.hash)
+    ) : CML.Credential.new_script(
+      CML.ScriptHash.from_hex(stakeCredential.hash)
+    )
+  ).to_address().to_bech32(void 0);
+}
+function validatorToRewardAddress(network, validator) {
+  const validatorHash = validatorToScriptHash(validator);
+  return CML.RewardAddress.new(
+    networkToId(network),
+    CML.Credential.new_script(CML.ScriptHash.from_hex(validatorHash))
+  ).to_address().to_bech32(void 0);
+}
+function getAddressDetails(address) {
+  try {
+    const parsedAddress = CML.BaseAddress.from_address(
+      addressFromHexOrBech32(address)
+    );
+    const paymentCredential = parsedAddress.payment().kind() === 0 ? {
+      type: "Key",
+      hash: parsedAddress.payment().as_pub_key().to_hex()
+    } : {
+      type: "Script",
+      hash: parsedAddress.payment().as_script().to_hex()
+    };
+    const stakeCredential = parsedAddress.stake().kind() === 0 ? {
+      type: "Key",
+      hash: parsedAddress.stake().as_pub_key().to_hex()
+    } : {
+      type: "Script",
+      hash: parsedAddress.stake().as_script().to_hex()
+    };
+    return {
+      type: "Base",
+      networkId: parsedAddress.to_address().network_id(),
+      address: {
+        bech32: parsedAddress.to_address().to_bech32(void 0),
+        hex: parsedAddress.to_address().to_hex()
+      },
+      paymentCredential,
+      stakeCredential
+    };
+  } catch (_e) {
+  }
+  try {
+    const parsedAddress = CML.EnterpriseAddress.from_address(
+      addressFromHexOrBech32(address)
+    );
+    const paymentCredential = parsedAddress.payment().kind() === 0 ? {
+      type: "Key",
+      hash: parsedAddress.payment().as_pub_key().to_hex()
+    } : {
+      type: "Script",
+      hash: parsedAddress.payment().as_script().to_hex()
+    };
+    return {
+      type: "Enterprise",
+      networkId: parsedAddress.to_address().network_id(),
+      address: {
+        bech32: parsedAddress.to_address().to_bech32(void 0),
+        hex: parsedAddress.to_address().to_hex()
+      },
+      paymentCredential
+    };
+  } catch (_e) {
+  }
+  try {
+    const parsedAddress = CML.PointerAddress.from_address(
+      addressFromHexOrBech32(address)
+    );
+    const paymentCredential = parsedAddress?.payment().kind() === 0 ? {
+      type: "Key",
+      hash: parsedAddress.payment().as_pub_key().to_hex()
+    } : {
+      type: "Script",
+      hash: parsedAddress.payment().as_script().to_hex()
+    };
+    return {
+      type: "Pointer",
+      networkId: parsedAddress.to_address().network_id(),
+      address: {
+        bech32: parsedAddress.to_address().to_bech32(void 0),
+        hex: parsedAddress.to_address().to_hex()
+      },
+      paymentCredential
+    };
+  } catch (_e) {
+  }
+  try {
+    const parsedAddress = CML.RewardAddress.from_address(
+      addressFromHexOrBech32(address)
+    );
+    const stakeCredential = parsedAddress.payment().kind() === 0 ? {
+      type: "Key",
+      hash: parsedAddress.payment().as_pub_key().to_hex()
+    } : {
+      type: "Script",
+      hash: parsedAddress.payment().as_script().to_hex()
+    };
+    return {
+      type: "Reward",
+      networkId: parsedAddress.to_address().network_id(),
+      address: {
+        bech32: parsedAddress.to_address().to_bech32(void 0),
+        hex: parsedAddress.to_address().to_hex()
+      },
+      stakeCredential
+    };
+  } catch (_e) {
+  }
+  try {
+    const parsedAddress = ((address2) => {
+      try {
+        return CML.ByronAddress.from_cbor_hex(address2);
+      } catch (_e) {
+        try {
+          return CML.ByronAddress.from_base58(address2);
+        } catch (_e2) {
+          throw new Error("Could not deserialize address.");
+        }
+      }
+    })(address);
+    return {
+      type: "Byron",
+      networkId: parsedAddress.content().network_id(),
+      address: {
+        bech32: "",
+        hex: parsedAddress.to_address().to_hex()
+      }
+    };
+  } catch (_e) {
+  }
+  throw new Error("No address type matched for: " + address);
+}
+
+// src/cost_model.ts
+function createCostModels(costModels) {
+  const costmodel = {
+    0: [],
+    1: [],
+    2: []
+  };
+  for (const cost of Object.values(costModels.PlutusV1)) {
+    costmodel[0]?.push(cost);
+  }
+  for (const cost of Object.values(costModels.PlutusV2)) {
+    costmodel[1]?.push(cost);
+  }
+  for (const cost of Object.values(costModels.PlutusV3)) {
+    costmodel[2]?.push(cost);
+  }
+  return CML.CostModels.from_json(JSON.stringify(costmodel));
+}
+var PROTOCOL_PARAMETERS_DEFAULT = {
+  minFeeA: 44,
+  minFeeB: 155381,
+  maxTxSize: 16384,
+  maxValSize: 5e3,
+  keyDeposit: 2000000n,
+  poolDeposit: 500000000n,
+  drepDeposit: 500000000n,
+  govActionDeposit: 100000000000n,
+  priceMem: 0.0577,
+  priceStep: 721e-7,
+  maxTxExMem: 14000000n,
+  maxTxExSteps: 10000000000n,
+  coinsPerUtxoByte: 4310n,
+  collateralPercentage: 150,
+  maxCollateralInputs: 3,
+  minFeeRefScriptCostPerByte: 15,
+  costModels: {
+    PlutusV1: {
+      "0": 100788,
+      "1": 420,
+      "2": 1,
+      "3": 1,
+      "4": 1e3,
+      "5": 173,
+      "6": 0,
+      "7": 1,
+      "8": 1e3,
+      "9": 59957,
+      "10": 4,
+      "11": 1,
+      "12": 11183,
+      "13": 32,
+      "14": 201305,
+      "15": 8356,
+      "16": 4,
+      "17": 16e3,
+      "18": 100,
+      "19": 16e3,
+      "20": 100,
+      "21": 16e3,
+      "22": 100,
+      "23": 16e3,
+      "24": 100,
+      "25": 16e3,
+      "26": 100,
+      "27": 16e3,
+      "28": 100,
+      "29": 100,
+      "30": 100,
+      "31": 16e3,
+      "32": 100,
+      "33": 94375,
+      "34": 32,
+      "35": 132994,
+      "36": 32,
+      "37": 61462,
+      "38": 4,
+      "39": 72010,
+      "40": 178,
+      "41": 0,
+      "42": 1,
+      "43": 22151,
+      "44": 32,
+      "45": 91189,
+      "46": 769,
+      "47": 4,
+      "48": 2,
+      "49": 85848,
+      "50": 228465,
+      "51": 122,
+      "52": 0,
+      "53": 1,
+      "54": 1,
+      "55": 1e3,
+      "56": 42921,
+      "57": 4,
+      "58": 2,
+      "59": 24548,
+      "60": 29498,
+      "61": 38,
+      "62": 1,
+      "63": 898148,
+      "64": 27279,
+      "65": 1,
+      "66": 51775,
+      "67": 558,
+      "68": 1,
+      "69": 39184,
+      "70": 1e3,
+      "71": 60594,
+      "72": 1,
+      "73": 141895,
+      "74": 32,
+      "75": 83150,
+      "76": 32,
+      "77": 15299,
+      "78": 32,
+      "79": 76049,
+      "80": 1,
+      "81": 13169,
+      "82": 4,
+      "83": 22100,
+      "84": 10,
+      "85": 28999,
+      "86": 74,
+      "87": 1,
+      "88": 28999,
+      "89": 74,
+      "90": 1,
+      "91": 43285,
+      "92": 552,
+      "93": 1,
+      "94": 44749,
+      "95": 541,
+      "96": 1,
+      "97": 33852,
+      "98": 32,
+      "99": 68246,
+      "100": 32,
+      "101": 72362,
+      "102": 32,
+      "103": 7243,
+      "104": 32,
+      "105": 7391,
+      "106": 32,
+      "107": 11546,
+      "108": 32,
+      "109": 85848,
+      "110": 228465,
+      "111": 122,
+      "112": 0,
+      "113": 1,
+      "114": 1,
+      "115": 90434,
+      "116": 519,
+      "117": 0,
+      "118": 1,
+      "119": 74433,
+      "120": 32,
+      "121": 85848,
+      "122": 228465,
+      "123": 122,
+      "124": 0,
+      "125": 1,
+      "126": 1,
+      "127": 85848,
+      "128": 228465,
+      "129": 122,
+      "130": 0,
+      "131": 1,
+      "132": 1,
+      "133": 270652,
+      "134": 22588,
+      "135": 4,
+      "136": 1457325,
+      "137": 64566,
+      "138": 4,
+      "139": 20467,
+      "140": 1,
+      "141": 4,
+      "142": 0,
+      "143": 141992,
+      "144": 32,
+      "145": 100788,
+      "146": 420,
+      "147": 1,
+      "148": 1,
+      "149": 81663,
+      "150": 32,
+      "151": 59498,
+      "152": 32,
+      "153": 20142,
+      "154": 32,
+      "155": 24588,
+      "156": 32,
+      "157": 20744,
+      "158": 32,
+      "159": 25933,
+      "160": 32,
+      "161": 24623,
+      "162": 32,
+      "163": 53384111,
+      "164": 14333,
+      "165": 10
+    },
+    PlutusV2: {
+      "0": 100788,
+      "1": 420,
+      "2": 1,
+      "3": 1,
+      "4": 1e3,
+      "5": 173,
+      "6": 0,
+      "7": 1,
+      "8": 1e3,
+      "9": 59957,
+      "10": 4,
+      "11": 1,
+      "12": 11183,
+      "13": 32,
+      "14": 201305,
+      "15": 8356,
+      "16": 4,
+      "17": 16e3,
+      "18": 100,
+      "19": 16e3,
+      "20": 100,
+      "21": 16e3,
+      "22": 100,
+      "23": 16e3,
+      "24": 100,
+      "25": 16e3,
+      "26": 100,
+      "27": 16e3,
+      "28": 100,
+      "29": 100,
+      "30": 100,
+      "31": 16e3,
+      "32": 100,
+      "33": 94375,
+      "34": 32,
+      "35": 132994,
+      "36": 32,
+      "37": 61462,
+      "38": 4,
+      "39": 72010,
+      "40": 178,
+      "41": 0,
+      "42": 1,
+      "43": 22151,
+      "44": 32,
+      "45": 91189,
+      "46": 769,
+      "47": 4,
+      "48": 2,
+      "49": 85848,
+      "50": 228465,
+      "51": 122,
+      "52": 0,
+      "53": 1,
+      "54": 1,
+      "55": 1e3,
+      "56": 42921,
+      "57": 4,
+      "58": 2,
+      "59": 24548,
+      "60": 29498,
+      "61": 38,
+      "62": 1,
+      "63": 898148,
+      "64": 27279,
+      "65": 1,
+      "66": 51775,
+      "67": 558,
+      "68": 1,
+      "69": 39184,
+      "70": 1e3,
+      "71": 60594,
+      "72": 1,
+      "73": 141895,
+      "74": 32,
+      "75": 83150,
+      "76": 32,
+      "77": 15299,
+      "78": 32,
+      "79": 76049,
+      "80": 1,
+      "81": 13169,
+      "82": 4,
+      "83": 22100,
+      "84": 10,
+      "85": 28999,
+      "86": 74,
+      "87": 1,
+      "88": 28999,
+      "89": 74,
+      "90": 1,
+      "91": 43285,
+      "92": 552,
+      "93": 1,
+      "94": 44749,
+      "95": 541,
+      "96": 1,
+      "97": 33852,
+      "98": 32,
+      "99": 68246,
+      "100": 32,
+      "101": 72362,
+      "102": 32,
+      "103": 7243,
+      "104": 32,
+      "105": 7391,
+      "106": 32,
+      "107": 11546,
+      "108": 32,
+      "109": 85848,
+      "110": 228465,
+      "111": 122,
+      "112": 0,
+      "113": 1,
+      "114": 1,
+      "115": 90434,
+      "116": 519,
+      "117": 0,
+      "118": 1,
+      "119": 74433,
+      "120": 32,
+      "121": 85848,
+      "122": 228465,
+      "123": 122,
+      "124": 0,
+      "125": 1,
+      "126": 1,
+      "127": 85848,
+      "128": 228465,
+      "129": 122,
+      "130": 0,
+      "131": 1,
+      "132": 1,
+      "133": 955506,
+      "134": 213312,
+      "135": 0,
+      "136": 2,
+      "137": 270652,
+      "138": 22588,
+      "139": 4,
+      "140": 1457325,
+      "141": 64566,
+      "142": 4,
+      "143": 20467,
+      "144": 1,
+      "145": 4,
+      "146": 0,
+      "147": 141992,
+      "148": 32,
+      "149": 100788,
+      "150": 420,
+      "151": 1,
+      "152": 1,
+      "153": 81663,
+      "154": 32,
+      "155": 59498,
+      "156": 32,
+      "157": 20142,
+      "158": 32,
+      "159": 24588,
+      "160": 32,
+      "161": 20744,
+      "162": 32,
+      "163": 25933,
+      "164": 32,
+      "165": 24623,
+      "166": 32,
+      "167": 43053543,
+      "168": 10,
+      "169": 53384111,
+      "170": 14333,
+      "171": 10,
+      "172": 43574283,
+      "173": 26308,
+      "174": 10
+    },
+    PlutusV3: {
+      "0": 100788,
+      "1": 420,
+      "2": 1,
+      "3": 1,
+      "4": 1e3,
+      "5": 173,
+      "6": 0,
+      "7": 1,
+      "8": 1e3,
+      "9": 59957,
+      "10": 4,
+      "11": 1,
+      "12": 11183,
+      "13": 32,
+      "14": 201305,
+      "15": 8356,
+      "16": 4,
+      "17": 16e3,
+      "18": 100,
+      "19": 16e3,
+      "20": 100,
+      "21": 16e3,
+      "22": 100,
+      "23": 16e3,
+      "24": 100,
+      "25": 16e3,
+      "26": 100,
+      "27": 16e3,
+      "28": 100,
+      "29": 100,
+      "30": 100,
+      "31": 16e3,
+      "32": 100,
+      "33": 94375,
+      "34": 32,
+      "35": 132994,
+      "36": 32,
+      "37": 61462,
+      "38": 4,
+      "39": 72010,
+      "40": 178,
+      "41": 0,
+      "42": 1,
+      "43": 22151,
+      "44": 32,
+      "45": 91189,
+      "46": 769,
+      "47": 4,
+      "48": 2,
+      "49": 85848,
+      "50": 123203,
+      "51": 7305,
+      "52": -900,
+      "53": 1716,
+      "54": 549,
+      "55": 57,
+      "56": 85848,
+      "57": 0,
+      "58": 1,
+      "59": 1,
+      "60": 1e3,
+      "61": 42921,
+      "62": 4,
+      "63": 2,
+      "64": 24548,
+      "65": 29498,
+      "66": 38,
+      "67": 1,
+      "68": 898148,
+      "69": 27279,
+      "70": 1,
+      "71": 51775,
+      "72": 558,
+      "73": 1,
+      "74": 39184,
+      "75": 1e3,
+      "76": 60594,
+      "77": 1,
+      "78": 141895,
+      "79": 32,
+      "80": 83150,
+      "81": 32,
+      "82": 15299,
+      "83": 32,
+      "84": 76049,
+      "85": 1,
+      "86": 13169,
+      "87": 4,
+      "88": 22100,
+      "89": 10,
+      "90": 28999,
+      "91": 74,
+      "92": 1,
+      "93": 28999,
+      "94": 74,
+      "95": 1,
+      "96": 43285,
+      "97": 552,
+      "98": 1,
+      "99": 44749,
+      "100": 541,
+      "101": 1,
+      "102": 33852,
+      "103": 32,
+      "104": 68246,
+      "105": 32,
+      "106": 72362,
+      "107": 32,
+      "108": 7243,
+      "109": 32,
+      "110": 7391,
+      "111": 32,
+      "112": 11546,
+      "113": 32,
+      "114": 85848,
+      "115": 123203,
+      "116": 7305,
+      "117": -900,
+      "118": 1716,
+      "119": 549,
+      "120": 57,
+      "121": 85848,
+      "122": 0,
+      "123": 1,
+      "124": 90434,
+      "125": 519,
+      "126": 0,
+      "127": 1,
+      "128": 74433,
+      "129": 32,
+      "130": 85848,
+      "131": 123203,
+      "132": 7305,
+      "133": -900,
+      "134": 1716,
+      "135": 549,
+      "136": 57,
+      "137": 85848,
+      "138": 0,
+      "139": 1,
+      "140": 1,
+      "141": 85848,
+      "142": 123203,
+      "143": 7305,
+      "144": -900,
+      "145": 1716,
+      "146": 549,
+      "147": 57,
+      "148": 85848,
+      "149": 0,
+      "150": 1,
+      "151": 955506,
+      "152": 213312,
+      "153": 0,
+      "154": 2,
+      "155": 270652,
+      "156": 22588,
+      "157": 4,
+      "158": 1457325,
+      "159": 64566,
+      "160": 4,
+      "161": 20467,
+      "162": 1,
+      "163": 4,
+      "164": 0,
+      "165": 141992,
+      "166": 32,
+      "167": 100788,
+      "168": 420,
+      "169": 1,
+      "170": 1,
+      "171": 81663,
+      "172": 32,
+      "173": 59498,
+      "174": 32,
+      "175": 20142,
+      "176": 32,
+      "177": 24588,
+      "178": 32,
+      "179": 20744,
+      "180": 32,
+      "181": 25933,
+      "182": 32,
+      "183": 24623,
+      "184": 32,
+      "185": 43053543,
+      "186": 10,
+      "187": 53384111,
+      "188": 14333,
+      "189": 10,
+      "190": 43574283,
+      "191": 26308,
+      "192": 10,
+      "193": 16e3,
+      "194": 100,
+      "195": 16e3,
+      "196": 100,
+      "197": 962335,
+      "198": 18,
+      "199": 2780678,
+      "200": 6,
+      "201": 442008,
+      "202": 1,
+      "203": 52538055,
+      "204": 3756,
+      "205": 18,
+      "206": 267929,
+      "207": 18,
+      "208": 76433006,
+      "209": 8868,
+      "210": 18,
+      "211": 52948122,
+      "212": 18,
+      "213": 1995836,
+      "214": 36,
+      "215": 3227919,
+      "216": 12,
+      "217": 901022,
+      "218": 1,
+      "219": 166917843,
+      "220": 4307,
+      "221": 36,
+      "222": 284546,
+      "223": 36,
+      "224": 158221314,
+      "225": 26549,
+      "226": 36,
+      "227": 74698472,
+      "228": 36,
+      "229": 333849714,
+      "230": 1,
+      "231": 254006273,
+      "232": 72,
+      "233": 2174038,
+      "234": 72,
+      "235": 2261318,
+      "236": 64571,
+      "237": 4,
+      "238": 207616,
+      "239": 8310,
+      "240": 4,
+      "241": 1293828,
+      "242": 28716,
+      "243": 63,
+      "244": 0,
+      "245": 1,
+      "246": 1006041,
+      "247": 43623,
+      "248": 251,
+      "249": 0,
+      "250": 1,
+      "251": 100181,
+      "252": 726,
+      "253": 719,
+      "254": 0,
+      "255": 1,
+      "256": 100181,
+      "257": 726,
+      "258": 719,
+      "259": 0,
+      "260": 1,
+      "261": 100181,
+      "262": 726,
+      "263": 719,
+      "264": 0,
+      "265": 1,
+      "266": 107878,
+      "267": 680,
+      "268": 0,
+      "269": 1,
+      "270": 95336,
+      "271": 1,
+      "272": 281145,
+      "273": 18848,
+      "274": 0,
+      "275": 1,
+      "276": 180194,
+      "277": 159,
+      "278": 1,
+      "279": 1,
+      "280": 158519,
+      "281": 8942,
+      "282": 0,
+      "283": 1,
+      "284": 159378,
+      "285": 8813,
+      "286": 0,
+      "287": 1,
+      "288": 107490,
+      "289": 3298,
+      "290": 1,
+      "291": 106057,
+      "292": 655,
+      "293": 1,
+      "294": 1964219,
+      "295": 24520,
+      "296": 3
+    }
+  }
+};
+
+// src/credential.ts
+function credentialToAddress(network, paymentCredential, stakeCredential) {
+  if (stakeCredential) {
+    return CML.BaseAddress.new(
+      networkToId(network),
+      paymentCredential.type === "Key" ? CML.Credential.new_pub_key(
+        CML.Ed25519KeyHash.from_hex(paymentCredential.hash)
+      ) : CML.Credential.new_script(
+        CML.ScriptHash.from_hex(paymentCredential.hash)
+      ),
+      stakeCredential.type === "Key" ? CML.Credential.new_pub_key(
+        CML.Ed25519KeyHash.from_hex(stakeCredential.hash)
+      ) : CML.Credential.new_script(
+        CML.ScriptHash.from_hex(stakeCredential.hash)
+      )
+    ).to_address().to_bech32(void 0);
+  } else {
+    return CML.EnterpriseAddress.new(
+      networkToId(network),
+      paymentCredential.type === "Key" ? CML.Credential.new_pub_key(
+        CML.Ed25519KeyHash.from_hex(paymentCredential.hash)
+      ) : CML.Credential.new_script(
+        CML.ScriptHash.from_hex(paymentCredential.hash)
+      )
+    ).to_address().to_bech32(void 0);
+  }
+}
+function scriptHashToCredential(scriptHash) {
+  return {
+    type: "Script",
+    hash: scriptHash
+  };
+}
+function keyHashToCredential(keyHash) {
+  return {
+    type: "Key",
+    hash: keyHash
+  };
+}
+function paymentCredentialOf(address) {
+  const { paymentCredential } = getAddressDetails(address);
+  if (!paymentCredential) {
+    throw new Error(
+      "The specified address does not contain a payment credential."
+    );
+  }
+  return paymentCredential;
+}
+function stakeCredentialOf(rewardAddress) {
+  const { stakeCredential } = getAddressDetails(rewardAddress);
+  if (!stakeCredential) {
+    throw new Error(
+      "The specified address does not contain a stake credential."
+    );
+  }
+  return stakeCredential;
+}
+
+// src/datum.ts
+function datumToHash(datum) {
+  return CML.hash_plutus_data(CML.PlutusData.from_cbor_hex(datum)).to_hex();
+}
+
+// src/keys.ts
+var import_bip39 = require("bip39");
+function generatePrivateKey() {
+  return CML.PrivateKey.generate_ed25519().to_bech32();
+}
+function generateSeedPhrase() {
+  return (0, import_bip39.generateMnemonic)(256);
+}
+function toPublicKey(privateKey) {
+  return CML.PrivateKey.from_bech32(privateKey).to_public().to_bech32();
+}
+
+// src/label.ts
+var import_core_utils3 = require("@lucid-evolution/core-utils");
+var import_crc8 = require("@lucid-evolution/crc8");
+function toLabel(num) {
+  if (num < 0 || num > 65535) {
+    throw new Error(
+      `Label ${num} out of range: min label 1 - max label 65535.`
+    );
+  }
+  const numHex = num.toString(16).padStart(4, "0");
+  return "0" + numHex + checksum(numHex) + "0";
+}
+function fromLabel(label) {
+  if (label.length !== 8 || !(label[0] === "0" && label[7] === "0")) {
+    return null;
+  }
+  const numHex = label.slice(1, 5);
+  const num = parseInt(numHex, 16);
+  const check = label.slice(5, 7);
+  return check === checksum(numHex) ? num : null;
+}
+function checksum(num) {
+  return (0, import_crc8.crc8)((0, import_core_utils3.fromHex)(num)).toString(16).padStart(2, "0");
+}
+
+// src/time.ts
+var import_plutus2 = require("@lucid-evolution/plutus");
+function unixTimeToSlot(network, unixTime) {
+  return (0, import_plutus2.unixTimeToEnclosingSlot)(unixTime, import_plutus2.SLOT_CONFIG_NETWORK[network]);
+}
+function slotToUnixTime(network, slot) {
+  return (0, import_plutus2.slotToBeginUnixTime)(slot, import_plutus2.SLOT_CONFIG_NETWORK[network]);
+}
+
+// src/value.ts
+var import_core_utils4 = require("@lucid-evolution/core-utils");
+var import_effect = require("effect");
+function valueToAssets(value) {
+  const assets = {};
+  assets["lovelace"] = value.coin();
+  if (value.has_multiassets()) {
+    const ma = value.multi_asset();
+    const multiAssets = ma.keys();
+    for (let j = 0; j < multiAssets.len(); j++) {
+      const policy = multiAssets.get(j);
+      const policyAssets = ma.get_assets(policy);
+      const assetNames = policyAssets.keys();
+      for (let k = 0; k < assetNames.len(); k++) {
+        const policyAsset = assetNames.get(k);
+        const quantity = policyAssets.get(policyAsset);
+        const unit = policy.to_hex() + policyAsset.to_js_value();
+        assets[unit] = quantity;
+      }
+    }
+  }
+  return assets;
+}
+function assetsToValue(assets) {
+  const multiAsset = CML.MultiAsset.new();
+  const lovelace = assets["lovelace"] ? BigInt(assets["lovelace"]) : 0n;
+  const units = Object.keys(assets);
+  const policies = Array.from(
+    new Set(
+      units.filter((unit) => unit !== "lovelace").map((unit) => unit.slice(0, 56))
+    )
+  );
+  for (const policy of policies) {
+    const policyUnits = units.filter((unit) => unit.slice(0, 56) === policy);
+    const assetsValue = CML.MapAssetNameToCoin.new();
+    for (const unit of policyUnits) {
+      assetsValue.insert(
+        CML.AssetName.from_hex(unit.slice(56)),
+        BigInt(assets[unit])
+      );
+    }
+    multiAsset.insert_assets(CML.ScriptHash.from_hex(policy), assetsValue);
+  }
+  return CML.Value.new(lovelace, multiAsset);
+}
+function fromUnit(unit) {
+  const policyId = unit.slice(0, 56);
+  const assetName = unit.slice(56) || null;
+  const label = fromLabel(unit.slice(56, 64));
+  const name = (() => {
+    const hexName = Number.isInteger(label) ? unit.slice(64) : unit.slice(56);
+    return hexName || null;
+  })();
+  return { policyId, assetName, name, label };
+}
+function toUnit(policyId, name, label) {
+  const hexLabel = Number.isInteger(label) ? toLabel(label) : "";
+  const n = name ? name : "";
+  if ((n + hexLabel).length > 64) {
+    throw new Error("Asset name size exceeds 32 bytes.");
+  }
+  if (policyId.length !== 56) {
+    throw new Error(`Policy id invalid: ${policyId}.`);
+  }
+  return policyId + hexLabel + n;
+}
+function addAssets(...assets) {
+  return assets.reduce((a, b) => {
+    for (const k in b) {
+      if (Object.hasOwn(b, k)) {
+        const sum = (a[k] || 0n) + b[k];
+        if (sum === 0n) {
+          delete a[k];
+        } else {
+          a[k] = sum;
+        }
+      }
+    }
+    return a;
+  }, {});
+}
+async function getUniqueTokenName(utxo) {
+  const id = (0, import_core_utils4.fromHex)(utxo.txHash);
+  const data = new Uint8Array([utxo.outputIndex, ...id]);
+  const hash = new Uint8Array(await crypto.subtle.digest("SHA3-256", data));
+  return (0, import_core_utils4.toHex)(hash);
+}
+var sortCanonical = (assets) => (0, import_effect.pipe)(
+  Object.entries(assets).sort(([aUnit], [bUnit]) => {
+    const a = fromUnit(aUnit);
+    const b = fromUnit(bUnit);
+    if (a.policyId.length !== b.policyId.length)
+      return a.policyId.length - b.policyId.length;
+    if (a.policyId === b.policyId) {
+      const aAssetName = a.assetName || "";
+      const bAssetName = b.assetName || "";
+      if (aAssetName.length !== bAssetName.length)
+        return aAssetName.length - bAssetName.length;
+      return aAssetName.localeCompare(bAssetName);
+    }
+    return a.policyId.localeCompare(b.policyId);
+  }),
+  Object.fromEntries
+);
+
+// src/utxo.ts
+var utxoToTransactionOutput = (utxo) => {
+  return buildOutput(utxo).with_value(assetsToValue(utxo.assets)).build().output();
+};
+var utxoToTransactionInput = (utxo) => {
+  return CML.TransactionInput.new(
+    CML.TransactionHash.from_hex(utxo.txHash),
+    BigInt(utxo.outputIndex)
+  );
+};
+var utxoToCore = (utxo) => {
+  const out = utxoToTransactionOutput(utxo);
+  const utxoCore = CML.TransactionUnspentOutput.new(
+    utxoToTransactionInput(utxo),
+    out
+  );
+  return utxoCore;
+};
+function utxosToCores(utxos) {
+  const result = [];
+  for (const utxo of utxos) {
+    result.push(utxoToCore(utxo));
+  }
+  return result;
+}
+function coreToUtxo(coreUtxo) {
+  const utxo = {
+    ...coreToOutRef(coreUtxo.input()),
+    ...coreToTxOutput(coreUtxo.output())
+  };
+  return utxo;
+}
+function coresToUtxos(utxos) {
+  const result = [];
+  for (let i = 0; i < utxos.length; i++) {
+    result.push(coreToUtxo(utxos[i]));
+  }
+  return result;
+}
+function coreToOutRef(input) {
+  return {
+    txHash: input.transaction_id().to_hex(),
+    outputIndex: parseInt(input.index().toString())
+  };
+}
+function coresToOutRefs(inputs) {
+  const result = [];
+  for (let i = 0; i < inputs.length; i++) {
+    result.push(coreToOutRef(inputs[i]));
+  }
+  return result;
+}
+function coreToTxOutput(output) {
+  return {
+    assets: valueToAssets(output.amount()),
+    address: output.address().to_bech32(void 0),
+    datumHash: output.datum()?.as_hash()?.to_hex(),
+    datum: output.datum()?.as_datum()?.to_cbor_hex(),
+    scriptRef: output.script_ref() && fromScriptRef(output.script_ref())
+  };
+}
+function coresToTxOutputs(outputs) {
+  let result = [];
+  for (let i = 0; i < outputs.length; i++) {
+    result.push(coreToTxOutput(outputs[i]));
+  }
+  return result;
+}
+var selectUTxOs = (utxos, totalAssets, includeUTxOsWithScriptRef = false) => {
+  const selectedUtxos = [];
+  let isSelected = false;
+  const assetsRequired = new Map(Object.entries(totalAssets));
+  for (const utxo of utxos) {
+    if (!includeUTxOsWithScriptRef && utxo.scriptRef) continue;
+    isSelected = false;
+    for (const [unit, amount] of assetsRequired) {
+      if (Object.hasOwn(utxo.assets, unit)) {
+        const utxoAmount = utxo.assets[unit];
+        if (utxoAmount >= amount) {
+          assetsRequired.delete(unit);
+        } else {
+          assetsRequired.set(unit, amount - utxoAmount);
+        }
+        isSelected = true;
+      }
+    }
+    if (isSelected) {
+      selectedUtxos.push(utxo);
+    }
+    if (assetsRequired.size == 0) {
+      break;
+    }
+  }
+  if (assetsRequired.size > 0) return [];
+  return selectedUtxos;
+};
+var sortUTxOs = (utxos, order = "LargestFirst") => {
+  switch (order) {
+    case "LargestFirst":
+      return [...utxos].sort(largestFirst);
+    case "SmallestFirst":
+      return [...utxos].sort(smallestFirst);
+    case "Canonical":
+      return [...utxos].sort(canonical);
+    case "Collateral":
+      return [...utxos].sort(collateralOrder);
+  }
+};
+var collateralOrder = (a, b) => {
+  const lovelaceA = Number(a.assets["lovelace"]);
+  const lovelaceB = Number(b.assets["lovelace"]);
+  const assetsA = Object.keys(a.assets).length;
+  const assetsB = Object.keys(b.assets).length;
+  if (assetsA === 0 && assetsB > 0) return -1;
+  if (assetsB === 0 && assetsA > 0) return 1;
+  return lovelaceB - lovelaceA;
+};
+var largestFirst = (a, b) => {
+  const lovelaceA = Number(a.assets["lovelace"]);
+  const lovelaceB = Number(b.assets["lovelace"]);
+  if (lovelaceA === lovelaceB) {
+    return Object.keys(a.assets).length - Object.keys(b.assets).length;
+  }
+  return -1 * (lovelaceA - lovelaceB);
+};
+var smallestFirst = (a, b) => {
+  const lovelaceA = Number(a.assets["lovelace"]);
+  const lovelaceB = Number(b.assets["lovelace"]);
+  if (lovelaceA == lovelaceB) {
+    return Object.keys(a.assets).length - Object.keys(b.assets).length;
+  }
+  return lovelaceA - lovelaceB;
+};
+var canonical = (a, b) => {
+  if (a.txHash < b.txHash) {
+    return -1;
+  } else if (a.txHash > b.txHash) {
+    return 1;
+  } else {
+    return a.outputIndex - b.outputIndex;
+  }
+};
+var isEqualUTxO = (self, that) => self.txHash === that.txHash && self.outputIndex === that.outputIndex;
+function getInputIndices(indexInputs, allInputs, sorted = false) {
+  const sortedInputs = sorted ? allInputs : sortUTxOs(allInputs, "Canonical");
+  const indicesMap = /* @__PURE__ */ new Map();
+  sortedInputs.forEach((value, index) => {
+    indicesMap.set(value.txHash + value.outputIndex, BigInt(index));
+  });
+  return indexInputs.flatMap((value) => {
+    const index = indicesMap.get(value.txHash + value.outputIndex);
+    if (index !== void 0) return index;
+    else return [];
+  });
+}
+var calculateMinLovelaceFromUTxO = (coinsPerUtxoByte, utxo) => buildOutput(utxo).with_asset_and_min_required_coin(
+  assetsToValue(utxo.assets).multi_asset(),
+  coinsPerUtxoByte
+).build().output().amount().coin();
+var buildOutput = (utxo) => {
+  const builder = CML.TransactionOutputBuilder.new().with_address(
+    CML.Address.from_bech32(utxo.address)
+  );
+  return utxo.scriptRef ? buildDatum(utxo, builder).with_reference_script(toScriptRef(utxo.scriptRef)).next() : buildDatum(utxo, builder).next();
+};
+var buildDatum = (utxo, builder) => {
+  if (utxo.datumHash && utxo.datum)
+    return builder.with_communication_data(
+      CML.PlutusData.from_cbor_hex(utxo.datum)
+    );
+  if (utxo.datum)
+    return builder.with_data(
+      CML.DatumOption.new_datum(CML.PlutusData.from_cbor_hex(utxo.datum))
+    );
+  return builder;
+};
+
+// src/objects.ts
+var stringify = (data) => JSON.stringify(
+  data,
+  (key, value) => typeof value === "bigint" ? value.toString() + "n" : value,
+  2
+);
+
+// src/redeemer.ts
+var toCMLRedeemerTag = (tag) => {
+  switch (tag) {
+    case "spend":
+      return CML.RedeemerTag.Spend;
+    case "mint":
+      return CML.RedeemerTag.Mint;
+    case "publish":
+      return CML.RedeemerTag.Cert;
+    case "withdraw":
+      return CML.RedeemerTag.Reward;
+    case "vote":
+      return CML.RedeemerTag.Voting;
+    case "propose":
+      return CML.RedeemerTag.Proposing;
+    default:
+      throw new Error(`Exhaustive check failed: Unhandled case ${tag}`);
+  }
+};
+var fromCMLRedeemerTag = (tag) => {
+  switch (tag) {
+    case CML.RedeemerTag.Spend:
+      return "spend";
+    case CML.RedeemerTag.Mint:
+      return "mint";
+    case CML.RedeemerTag.Cert:
+      return "publish";
+    case CML.RedeemerTag.Reward:
+      return "withdraw";
+    case CML.RedeemerTag.Voting:
+      return "vote";
+    case CML.RedeemerTag.Proposing:
+      return "propose";
+    default:
+      throw new Error(`Exhaustive check failed: Unhandled case ${tag}`);
+  }
+};
+// Annotate the CommonJS export names for ESM import in node:
+0 && (module.exports = {
+  CBOREncodingLevel,
+  PROTOCOL_PARAMETERS_DEFAULT,
+  addAssets,
+  addressFromHexOrBech32,
+  applyDoubleCborEncoding,
+  applyParamsToScript,
+  applySingleCborEncoding,
+  assetsToValue,
+  calculateMinLovelaceFromUTxO,
+  coreToOutRef,
+  coreToTxOutput,
+  coreToUtxo,
+  coresToOutRefs,
+  coresToTxOutputs,
+  coresToUtxos,
+  createCostModels,
+  credentialToAddress,
+  credentialToRewardAddress,
+  datumJsonToCbor,
+  datumToHash,
+  fromCMLRedeemerTag,
+  fromLabel,
+  fromScriptRef,
+  fromUnit,
+  generatePrivateKey,
+  generateSeedPhrase,
+  getAddressDetails,
+  getInputIndices,
+  getUniqueTokenName,
+  isEqualUTxO,
+  keyHashToCredential,
+  mintingPolicyToId,
+  networkToId,
+  parseCMLNative,
+  paymentCredentialOf,
+  scriptFromCMLNative,
+  scriptFromNative,
+  scriptHashToCredential,
+  selectUTxOs,
+  slotToUnixTime,
+  sortCanonical,
+  sortUTxOs,
+  stakeCredentialOf,
+  stringify,
+  toCMLNativeScript,
+  toCMLRedeemerTag,
+  toLabel,
+  toPublicKey,
+  toScriptRef,
+  toUnit,
+  unixTimeToSlot,
+  utxoToCore,
+  utxoToTransactionInput,
+  utxoToTransactionOutput,
+  utxosToCores,
+  validatorToAddress,
+  validatorToRewardAddress,
+  validatorToScriptHash,
+  valueToAssets
+});
diff --git a/node_modules/@lucid-evolution/utils/index.d.cts b/node_modules/@lucid-evolution/utils/index.d.cts
new file mode 100644
index 0000000..eb37cf3
--- /dev/null
+++ b/node_modules/@lucid-evolution/utils/index.d.cts
@@ -0,0 +1,211 @@
+import * as _effect_schema_AST from '@effect/schema/AST';
+import { Native, Script, Network, Credential, RewardAddress, CertificateValidator, WithdrawalValidator, AddressDetails, DatumJson, Datum, CostModels, ProtocolParameters, Address, ScriptHash, KeyHash, DatumHash, PrivateKey, PublicKey, SpendingValidator, Validator, MintingPolicy, PolicyId, Exact, UnixTime, Slot, UTxO, OutRef, TxOutput, Assets, Unit, RedeemerTag } from '@lucid-evolution/core-types';
+import * as CML from '@anastasia-labs/cardano-multiplatform-lib-nodejs';
+import { Data } from '@lucid-evolution/plutus';
+
+/**
+ * Converts a Native type (cardano-cli JSON script syntax) to CML.NativeScript.
+ *
+ * Native type follows the standard described in the
+ * {@link https://github.com/IntersectMBO/cardano-node/blob/1.26.1-with-cardano-cli/doc/reference/simple-scripts.md#json-script-syntax JSON script syntax documentation}.
+ */
+declare const toCMLNativeScript: (native: Native) => CML.NativeScript;
+/**
+ * Builds a Script from Native type (cardano-cli JSON script syntax).
+ *
+ * Native type follows the standard described in the
+ * {@link https://github.com/IntersectMBO/cardano-node/blob/1.26.1-with-cardano-cli/doc/reference/simple-scripts.md#json-script-syntax JSON script syntax documentation}.
+ */
+declare const scriptFromNative: (native: Native) => Script;
+/**
+ * Represents a CML JSON script syntax
+ */
+type CMLNative = {
+    ScriptPubkey: {
+        ed25519_key_hash: string;
+    };
+} | {
+    ScriptInvalidBefore: {
+        before: number;
+    };
+} | {
+    ScriptInvalidHereafter: {
+        after: number;
+    };
+} | {
+    ScriptAll: {
+        native_scripts: ReadonlyArray<CMLNative>;
+    };
+} | {
+    ScriptAny: {
+        native_scripts: ReadonlyArray<CMLNative>;
+    };
+} | {
+    ScriptNOfK: {
+        n: number;
+        native_scripts: ReadonlyArray<CMLNative>;
+    };
+};
+/**
+ * Parses a CMLNative type from an unknown input using effect schema.
+ * This function is useful for decoding unknown data to CMLNative from a file or an API.
+ *
+ *  @throws {ParseError} - Throws a ParseError if the input does not conform to the schema.
+ */
+declare const parseCMLNative: (u: unknown, overrideOptions?: _effect_schema_AST.ParseOptions) => CMLNative;
+/**
+ * Builds a Script from CMLNative script type.
+ *
+ */
+declare const scriptFromCMLNative: (cmlNative: CMLNative) => Script;
+
+declare function addressFromHexOrBech32(address: string): CML.Address;
+declare function credentialToRewardAddress(network: Network, stakeCredential: Credential): RewardAddress;
+declare function validatorToRewardAddress(network: Network, validator: CertificateValidator | WithdrawalValidator): RewardAddress;
+/** Address can be in Bech32 or Hex. */
+declare function getAddressDetails(address: string): AddressDetails;
+
+declare const applyDoubleCborEncoding: (script: string) => string;
+declare const applySingleCborEncoding: (script: string) => string;
+declare const CBOREncodingLevel: (script: string) => "double" | "single";
+declare function datumJsonToCbor(json: DatumJson): Datum;
+
+declare function createCostModels(costModels: CostModels): CML.CostModels;
+declare const PROTOCOL_PARAMETERS_DEFAULT: ProtocolParameters;
+
+declare function credentialToAddress(network: Network, paymentCredential: Credential, stakeCredential?: Credential): Address;
+declare function scriptHashToCredential(scriptHash: ScriptHash): Credential;
+declare function keyHashToCredential(keyHash: KeyHash): Credential;
+declare function paymentCredentialOf(address: Address): Credential;
+declare function stakeCredentialOf(rewardAddress: RewardAddress): Credential;
+
+declare function datumToHash(datum: Datum): DatumHash;
+
+declare function generatePrivateKey(): PrivateKey;
+declare function generateSeedPhrase(): string;
+declare function toPublicKey(privateKey: PrivateKey): PublicKey;
+
+declare function toLabel(num: number): string;
+declare function fromLabel(label: string): number | null;
+
+declare function networkToId(network: Network): number;
+
+declare function validatorToAddress(network: Network, validator: SpendingValidator, stakeCredential?: Credential): Address;
+declare function validatorToScriptHash(validator: Validator): ScriptHash;
+declare function toScriptRef(script: Script): CML.Script;
+declare function fromScriptRef(scriptRef: CML.Script): Script;
+declare function mintingPolicyToId(mintingPolicy: MintingPolicy): PolicyId;
+/**
+ * Applies a list of parameters, in the form of the `Data` type, to a CBOR encoded script.
+ *
+ * The `plutusScript` must be double CBOR encoded(bytes). Ensure to use the `applyDoubleCborEncoding` function.
+ */
+declare function applyParamsToScript<T extends unknown[] = Data[]>(plutusScript: string, params: Exact<[...T]>, type?: T): string;
+
+/**
+ * Converts unix time to slot based on the network. For "Custom" network
+ * it is advisable use `unixTimeToSlot` method from `LucidEvolution`
+ * instance to avoid uninitialized `SLOT_CONFIG_NETWORK` issue. More details
+ * on the issue can be found here https://github.com/Anastasia-Labs/lucid-evolution/pull/443
+ * @param network
+ * @param unixTime
+ * @returns Slot
+ */
+declare function unixTimeToSlot(network: Network, unixTime: UnixTime): Slot;
+declare function slotToUnixTime(network: Network, slot: Slot): UnixTime;
+
+declare const utxoToTransactionOutput: (utxo: UTxO) => CML.TransactionOutput;
+declare const utxoToTransactionInput: (utxo: UTxO) => CML.TransactionInput;
+declare const utxoToCore: (utxo: UTxO) => CML.TransactionUnspentOutput;
+declare function utxosToCores(utxos: UTxO[]): CML.TransactionUnspentOutput[];
+declare function coreToUtxo(coreUtxo: CML.TransactionUnspentOutput): UTxO;
+declare function coresToUtxos(utxos: CML.TransactionUnspentOutput[]): UTxO[];
+declare function coreToOutRef(input: CML.TransactionInput): OutRef;
+declare function coresToOutRefs(inputs: CML.TransactionInput[]): OutRef[];
+declare function coreToTxOutput(output: CML.TransactionOutput): TxOutput;
+declare function coresToTxOutputs(outputs: CML.TransactionOutput[]): TxOutput[];
+/**
+ * Returns a list of UTxOs whose total assets are equal to or greater than the asset value provided
+ * @param utxos list of available utxos
+ * @param totalAssets minimum total assets required
+ * @param includeUTxOsWithScriptRef Whether to include UTxOs with scriptRef or not. default = false
+ */
+declare const selectUTxOs: (utxos: UTxO[], totalAssets: Assets, includeUTxOsWithScriptRef?: boolean) => UTxO[];
+/**
+ * Union type for specifying sorting order in function "sortUTxOs"
+ */
+type SortOrder = 
+/**
+ * Largest amount of "lovelace" with least number of unique assets first
+ */
+"LargestFirst"
+/**
+ * Smallest amount of "lovelace" with least number of unique assets first
+ */
+ | "SmallestFirst"
+/**
+ * Similar to Largest first, but we preference "clean" UTxOs first
+ */
+ | "Collateral"
+/**
+ * Lexicographically sorted as per ledger rules
+ */
+ | "Canonical";
+/**
+ * Sorts an array of UTXOs according to specified sort order ("LargestFirst" by default).
+ * The provided array is cloned and reference to the new sorted array is returned.
+ *
+ * @param {UTxO[]} utxos - The array of UTXO objects to be sorted.
+ * @param {SortOrder} [order="LargestFirst"] - The order in which to sort the UTXOs.
+ * @returns {UTxO[]} - The sorted array of UTXOs.
+ *
+ */
+declare const sortUTxOs: (utxos: UTxO[], order?: SortOrder) => UTxO[];
+declare const isEqualUTxO: (self: UTxO, that: UTxO) => boolean;
+/**
+ * Provides an array of input indices for given "indexInputs" UTxOs.
+ * Indices obtained from the list of transaction inputs which are
+ * ordered as per ledger rules.
+ *
+ * @param indexInputs Input utxos whose indices need to be returned
+ * @param allInputs All the inputs utxos being spent by the transaction
+ * @param sorted Whether the provided "allInputs" are sorted canonically or not
+ * @returns Input indices of utxos as they appear in "indexInputs"
+ */
+declare function getInputIndices(indexInputs: UTxO[], allInputs: UTxO[], sorted?: Boolean): bigint[];
+declare const calculateMinLovelaceFromUTxO: (coinsPerUtxoByte: bigint, utxo: UTxO) => bigint;
+
+declare function valueToAssets(value: CML.Value): Assets;
+declare function assetsToValue(assets: Assets): CML.Value;
+/**
+ * Splits unit into policy id, asset name (entire asset name), name (asset name without label) and label if applicable.
+ * name will be returned in Hex.
+ */
+declare function fromUnit(unit: Unit): {
+    policyId: PolicyId;
+    assetName: string | null;
+    name: string | null;
+    label: number | null;
+};
+/**
+ * @param name Hex encoded
+ */
+declare function toUnit(policyId: PolicyId, name?: string | null, label?: number | null): Unit;
+declare function addAssets(...assets: Assets[]): Assets;
+/**
+ * Returns a unique token name which is SHA3-256 hash of UTxO's txid and idx
+ * @param utxo UTxO whose OutRef will be used
+ */
+declare function getUniqueTokenName(utxo: UTxO): Promise<string>;
+/**
+ *
+ * Sort Assets following [RFC 7049 Section 3.9](https://datatracker.ietf.org/doc/html/rfc7049#section-3.9) sorting rules
+ */
+declare const sortCanonical: (assets: Assets) => Assets;
+
+declare const stringify: (data: any) => string;
+
+declare const toCMLRedeemerTag: (tag: string) => CML.RedeemerTag;
+declare const fromCMLRedeemerTag: (tag: CML.RedeemerTag) => RedeemerTag;
+
+export { CBOREncodingLevel, type CMLNative, PROTOCOL_PARAMETERS_DEFAULT, type SortOrder, addAssets, addressFromHexOrBech32, applyDoubleCborEncoding, applyParamsToScript, applySingleCborEncoding, assetsToValue, calculateMinLovelaceFromUTxO, coreToOutRef, coreToTxOutput, coreToUtxo, coresToOutRefs, coresToTxOutputs, coresToUtxos, createCostModels, credentialToAddress, credentialToRewardAddress, datumJsonToCbor, datumToHash, fromCMLRedeemerTag, fromLabel, fromScriptRef, fromUnit, generatePrivateKey, generateSeedPhrase, getAddressDetails, getInputIndices, getUniqueTokenName, isEqualUTxO, keyHashToCredential, mintingPolicyToId, networkToId, parseCMLNative, paymentCredentialOf, scriptFromCMLNative, scriptFromNative, scriptHashToCredential, selectUTxOs, slotToUnixTime, sortCanonical, sortUTxOs, stakeCredentialOf, stringify, toCMLNativeScript, toCMLRedeemerTag, toLabel, toPublicKey, toScriptRef, toUnit, unixTimeToSlot, utxoToCore, utxoToTransactionInput, utxoToTransactionOutput, utxosToCores, validatorToAddress, validatorToRewardAddress, validatorToScriptHash, valueToAssets };
diff --git a/node_modules/@lucid-evolution/utils/index.d.ts b/node_modules/@lucid-evolution/utils/index.d.ts
new file mode 100644
index 0000000..eb37cf3
--- /dev/null
+++ b/node_modules/@lucid-evolution/utils/index.d.ts
@@ -0,0 +1,211 @@
+import * as _effect_schema_AST from '@effect/schema/AST';
+import { Native, Script, Network, Credential, RewardAddress, CertificateValidator, WithdrawalValidator, AddressDetails, DatumJson, Datum, CostModels, ProtocolParameters, Address, ScriptHash, KeyHash, DatumHash, PrivateKey, PublicKey, SpendingValidator, Validator, MintingPolicy, PolicyId, Exact, UnixTime, Slot, UTxO, OutRef, TxOutput, Assets, Unit, RedeemerTag } from '@lucid-evolution/core-types';
+import * as CML from '@anastasia-labs/cardano-multiplatform-lib-nodejs';
+import { Data } from '@lucid-evolution/plutus';
+
+/**
+ * Converts a Native type (cardano-cli JSON script syntax) to CML.NativeScript.
+ *
+ * Native type follows the standard described in the
+ * {@link https://github.com/IntersectMBO/cardano-node/blob/1.26.1-with-cardano-cli/doc/reference/simple-scripts.md#json-script-syntax JSON script syntax documentation}.
+ */
+declare const toCMLNativeScript: (native: Native) => CML.NativeScript;
+/**
+ * Builds a Script from Native type (cardano-cli JSON script syntax).
+ *
+ * Native type follows the standard described in the
+ * {@link https://github.com/IntersectMBO/cardano-node/blob/1.26.1-with-cardano-cli/doc/reference/simple-scripts.md#json-script-syntax JSON script syntax documentation}.
+ */
+declare const scriptFromNative: (native: Native) => Script;
+/**
+ * Represents a CML JSON script syntax
+ */
+type CMLNative = {
+    ScriptPubkey: {
+        ed25519_key_hash: string;
+    };
+} | {
+    ScriptInvalidBefore: {
+        before: number;
+    };
+} | {
+    ScriptInvalidHereafter: {
+        after: number;
+    };
+} | {
+    ScriptAll: {
+        native_scripts: ReadonlyArray<CMLNative>;
+    };
+} | {
+    ScriptAny: {
+        native_scripts: ReadonlyArray<CMLNative>;
+    };
+} | {
+    ScriptNOfK: {
+        n: number;
+        native_scripts: ReadonlyArray<CMLNative>;
+    };
+};
+/**
+ * Parses a CMLNative type from an unknown input using effect schema.
+ * This function is useful for decoding unknown data to CMLNative from a file or an API.
+ *
+ *  @throws {ParseError} - Throws a ParseError if the input does not conform to the schema.
+ */
+declare const parseCMLNative: (u: unknown, overrideOptions?: _effect_schema_AST.ParseOptions) => CMLNative;
+/**
+ * Builds a Script from CMLNative script type.
+ *
+ */
+declare const scriptFromCMLNative: (cmlNative: CMLNative) => Script;
+
+declare function addressFromHexOrBech32(address: string): CML.Address;
+declare function credentialToRewardAddress(network: Network, stakeCredential: Credential): RewardAddress;
+declare function validatorToRewardAddress(network: Network, validator: CertificateValidator | WithdrawalValidator): RewardAddress;
+/** Address can be in Bech32 or Hex. */
+declare function getAddressDetails(address: string): AddressDetails;
+
+declare const applyDoubleCborEncoding: (script: string) => string;
+declare const applySingleCborEncoding: (script: string) => string;
+declare const CBOREncodingLevel: (script: string) => "double" | "single";
+declare function datumJsonToCbor(json: DatumJson): Datum;
+
+declare function createCostModels(costModels: CostModels): CML.CostModels;
+declare const PROTOCOL_PARAMETERS_DEFAULT: ProtocolParameters;
+
+declare function credentialToAddress(network: Network, paymentCredential: Credential, stakeCredential?: Credential): Address;
+declare function scriptHashToCredential(scriptHash: ScriptHash): Credential;
+declare function keyHashToCredential(keyHash: KeyHash): Credential;
+declare function paymentCredentialOf(address: Address): Credential;
+declare function stakeCredentialOf(rewardAddress: RewardAddress): Credential;
+
+declare function datumToHash(datum: Datum): DatumHash;
+
+declare function generatePrivateKey(): PrivateKey;
+declare function generateSeedPhrase(): string;
+declare function toPublicKey(privateKey: PrivateKey): PublicKey;
+
+declare function toLabel(num: number): string;
+declare function fromLabel(label: string): number | null;
+
+declare function networkToId(network: Network): number;
+
+declare function validatorToAddress(network: Network, validator: SpendingValidator, stakeCredential?: Credential): Address;
+declare function validatorToScriptHash(validator: Validator): ScriptHash;
+declare function toScriptRef(script: Script): CML.Script;
+declare function fromScriptRef(scriptRef: CML.Script): Script;
+declare function mintingPolicyToId(mintingPolicy: MintingPolicy): PolicyId;
+/**
+ * Applies a list of parameters, in the form of the `Data` type, to a CBOR encoded script.
+ *
+ * The `plutusScript` must be double CBOR encoded(bytes). Ensure to use the `applyDoubleCborEncoding` function.
+ */
+declare function applyParamsToScript<T extends unknown[] = Data[]>(plutusScript: string, params: Exact<[...T]>, type?: T): string;
+
+/**
+ * Converts unix time to slot based on the network. For "Custom" network
+ * it is advisable use `unixTimeToSlot` method from `LucidEvolution`
+ * instance to avoid uninitialized `SLOT_CONFIG_NETWORK` issue. More details
+ * on the issue can be found here https://github.com/Anastasia-Labs/lucid-evolution/pull/443
+ * @param network
+ * @param unixTime
+ * @returns Slot
+ */
+declare function unixTimeToSlot(network: Network, unixTime: UnixTime): Slot;
+declare function slotToUnixTime(network: Network, slot: Slot): UnixTime;
+
+declare const utxoToTransactionOutput: (utxo: UTxO) => CML.TransactionOutput;
+declare const utxoToTransactionInput: (utxo: UTxO) => CML.TransactionInput;
+declare const utxoToCore: (utxo: UTxO) => CML.TransactionUnspentOutput;
+declare function utxosToCores(utxos: UTxO[]): CML.TransactionUnspentOutput[];
+declare function coreToUtxo(coreUtxo: CML.TransactionUnspentOutput): UTxO;
+declare function coresToUtxos(utxos: CML.TransactionUnspentOutput[]): UTxO[];
+declare function coreToOutRef(input: CML.TransactionInput): OutRef;
+declare function coresToOutRefs(inputs: CML.TransactionInput[]): OutRef[];
+declare function coreToTxOutput(output: CML.TransactionOutput): TxOutput;
+declare function coresToTxOutputs(outputs: CML.TransactionOutput[]): TxOutput[];
+/**
+ * Returns a list of UTxOs whose total assets are equal to or greater than the asset value provided
+ * @param utxos list of available utxos
+ * @param totalAssets minimum total assets required
+ * @param includeUTxOsWithScriptRef Whether to include UTxOs with scriptRef or not. default = false
+ */
+declare const selectUTxOs: (utxos: UTxO[], totalAssets: Assets, includeUTxOsWithScriptRef?: boolean) => UTxO[];
+/**
+ * Union type for specifying sorting order in function "sortUTxOs"
+ */
+type SortOrder = 
+/**
+ * Largest amount of "lovelace" with least number of unique assets first
+ */
+"LargestFirst"
+/**
+ * Smallest amount of "lovelace" with least number of unique assets first
+ */
+ | "SmallestFirst"
+/**
+ * Similar to Largest first, but we preference "clean" UTxOs first
+ */
+ | "Collateral"
+/**
+ * Lexicographically sorted as per ledger rules
+ */
+ | "Canonical";
+/**
+ * Sorts an array of UTXOs according to specified sort order ("LargestFirst" by default).
+ * The provided array is cloned and reference to the new sorted array is returned.
+ *
+ * @param {UTxO[]} utxos - The array of UTXO objects to be sorted.
+ * @param {SortOrder} [order="LargestFirst"] - The order in which to sort the UTXOs.
+ * @returns {UTxO[]} - The sorted array of UTXOs.
+ *
+ */
+declare const sortUTxOs: (utxos: UTxO[], order?: SortOrder) => UTxO[];
+declare const isEqualUTxO: (self: UTxO, that: UTxO) => boolean;
+/**
+ * Provides an array of input indices for given "indexInputs" UTxOs.
+ * Indices obtained from the list of transaction inputs which are
+ * ordered as per ledger rules.
+ *
+ * @param indexInputs Input utxos whose indices need to be returned
+ * @param allInputs All the inputs utxos being spent by the transaction
+ * @param sorted Whether the provided "allInputs" are sorted canonically or not
+ * @returns Input indices of utxos as they appear in "indexInputs"
+ */
+declare function getInputIndices(indexInputs: UTxO[], allInputs: UTxO[], sorted?: Boolean): bigint[];
+declare const calculateMinLovelaceFromUTxO: (coinsPerUtxoByte: bigint, utxo: UTxO) => bigint;
+
+declare function valueToAssets(value: CML.Value): Assets;
+declare function assetsToValue(assets: Assets): CML.Value;
+/**
+ * Splits unit into policy id, asset name (entire asset name), name (asset name without label) and label if applicable.
+ * name will be returned in Hex.
+ */
+declare function fromUnit(unit: Unit): {
+    policyId: PolicyId;
+    assetName: string | null;
+    name: string | null;
+    label: number | null;
+};
+/**
+ * @param name Hex encoded
+ */
+declare function toUnit(policyId: PolicyId, name?: string | null, label?: number | null): Unit;
+declare function addAssets(...assets: Assets[]): Assets;
+/**
+ * Returns a unique token name which is SHA3-256 hash of UTxO's txid and idx
+ * @param utxo UTxO whose OutRef will be used
+ */
+declare function getUniqueTokenName(utxo: UTxO): Promise<string>;
+/**
+ *
+ * Sort Assets following [RFC 7049 Section 3.9](https://datatracker.ietf.org/doc/html/rfc7049#section-3.9) sorting rules
+ */
+declare const sortCanonical: (assets: Assets) => Assets;
+
+declare const stringify: (data: any) => string;
+
+declare const toCMLRedeemerTag: (tag: string) => CML.RedeemerTag;
+declare const fromCMLRedeemerTag: (tag: CML.RedeemerTag) => RedeemerTag;
+
+export { CBOREncodingLevel, type CMLNative, PROTOCOL_PARAMETERS_DEFAULT, type SortOrder, addAssets, addressFromHexOrBech32, applyDoubleCborEncoding, applyParamsToScript, applySingleCborEncoding, assetsToValue, calculateMinLovelaceFromUTxO, coreToOutRef, coreToTxOutput, coreToUtxo, coresToOutRefs, coresToTxOutputs, coresToUtxos, createCostModels, credentialToAddress, credentialToRewardAddress, datumJsonToCbor, datumToHash, fromCMLRedeemerTag, fromLabel, fromScriptRef, fromUnit, generatePrivateKey, generateSeedPhrase, getAddressDetails, getInputIndices, getUniqueTokenName, isEqualUTxO, keyHashToCredential, mintingPolicyToId, networkToId, parseCMLNative, paymentCredentialOf, scriptFromCMLNative, scriptFromNative, scriptHashToCredential, selectUTxOs, slotToUnixTime, sortCanonical, sortUTxOs, stakeCredentialOf, stringify, toCMLNativeScript, toCMLRedeemerTag, toLabel, toPublicKey, toScriptRef, toUnit, unixTimeToSlot, utxoToCore, utxoToTransactionInput, utxoToTransactionOutput, utxosToCores, validatorToAddress, validatorToRewardAddress, validatorToScriptHash, valueToAssets };
diff --git a/node_modules/@lucid-evolution/utils/index.js b/node_modules/@lucid-evolution/utils/index.js
new file mode 100644
index 0000000..c596343
--- /dev/null
+++ b/node_modules/@lucid-evolution/utils/index.js
@@ -0,0 +1,1651 @@
+// src/native.ts
+import * as S from "@effect/schema/Schema";
+
+// src/core.ts
+import * as CML from "@anastasia-labs/cardano-multiplatform-lib-nodejs";
+
+// src/native.ts
+var toCMLNativeScript = (native) => {
+  switch (native.type) {
+    case "sig":
+      return CML.NativeScript.new_script_pubkey(
+        CML.Ed25519KeyHash.from_hex(native.keyHash)
+      );
+    case "before":
+      return CML.NativeScript.new_script_invalid_hereafter(BigInt(native.slot));
+    case "after":
+      return CML.NativeScript.new_script_invalid_before(BigInt(native.slot));
+    case "all": {
+      const nativeList = CML.NativeScriptList.new();
+      native.scripts.map((script) => nativeList.add(toCMLNativeScript(script)));
+      return CML.NativeScript.new_script_all(nativeList);
+    }
+    case "any": {
+      const nativeList = CML.NativeScriptList.new();
+      native.scripts.map((script) => nativeList.add(toCMLNativeScript(script)));
+      return CML.NativeScript.new_script_any(nativeList);
+    }
+    case "atLeast": {
+      const nativeList = CML.NativeScriptList.new();
+      native.scripts.map((script) => nativeList.add(toCMLNativeScript(script)));
+      return CML.NativeScript.new_script_n_of_k(
+        BigInt(native.required),
+        nativeList
+      );
+    }
+  }
+};
+var scriptFromNative = (native) => {
+  return {
+    type: "Native",
+    script: toCMLNativeScript(native).to_cbor_hex()
+  };
+};
+var CMLNativeSchema = S.Union(
+  S.Struct({
+    ScriptPubkey: S.Struct({
+      ed25519_key_hash: S.String
+    })
+  }),
+  S.Struct({
+    ScriptInvalidBefore: S.Struct({
+      before: S.Number
+    })
+  }),
+  S.Struct({
+    ScriptInvalidHereafter: S.Struct({
+      after: S.Number
+    })
+  }),
+  S.Struct({
+    ScriptAll: S.Struct({
+      native_scripts: S.Array(S.suspend(() => CMLNativeSchema))
+    })
+  }),
+  S.Struct({
+    ScriptAny: S.Struct({
+      native_scripts: S.Array(S.suspend(() => CMLNativeSchema))
+    })
+  }),
+  S.Struct({
+    ScriptNOfK: S.Struct({
+      n: S.Number,
+      native_scripts: S.Array(S.suspend(() => CMLNativeSchema))
+    })
+  })
+);
+var parseCMLNative = S.decodeUnknownSync(CMLNativeSchema);
+var scriptFromCMLNative = (cmlNative) => {
+  return {
+    type: "Native",
+    script: CML.NativeScript.from_json(JSON.stringify(cmlNative)).to_cbor_hex()
+  };
+};
+
+// src/network.ts
+function networkToId(network) {
+  switch (network) {
+    case "Preview":
+      return 0;
+    case "Preprod":
+      return 0;
+    case "Custom":
+      return 0;
+    case "Mainnet":
+      return 1;
+    default:
+      throw new Error("Network not found");
+  }
+}
+
+// src/cbor.ts
+import { fromHex, toHex } from "@lucid-evolution/core-utils";
+import { decode, encode } from "cbor-x";
+var applyDoubleCborEncoding = (script) => {
+  try {
+    decode(decode(fromHex(script)));
+    return script;
+  } catch (error) {
+    try {
+      decode(fromHex(script));
+      return toHex(Uint8Array.from(encode(fromHex(script).buffer)));
+    } catch (error2) {
+      return toHex(Uint8Array.from(encode(encode(fromHex(script).buffer))));
+    }
+  }
+};
+var applySingleCborEncoding = (script) => {
+  try {
+    decode(decode(fromHex(script)));
+    return toHex(decode(fromHex(script)));
+  } catch (error) {
+    try {
+      decode(fromHex(script));
+      return script;
+    } catch (error2) {
+      return toHex(Uint8Array.from(encode(fromHex(script).buffer)));
+    }
+  }
+};
+var CBOREncodingLevel = (script) => {
+  try {
+    decode(decode(fromHex(script)));
+    return "double";
+  } catch (error) {
+    try {
+      decode(fromHex(script));
+      return "single";
+    } catch (error2) {
+      throw new Error("Script is not CBOR-encoded or invalid format.");
+    }
+  }
+};
+function datumJsonToCbor(json) {
+  const convert = (json2) => {
+    if (!isNaN(json2.int)) {
+      const plutusBigInt = CML.BigInteger.from_str(json2.int.toString());
+      return CML.PlutusData.new_integer(plutusBigInt);
+    } else if (json2.bytes || !isNaN(Number(json2.bytes))) {
+      return CML.PlutusData.new_bytes(fromHex(json2.bytes));
+    } else if (json2.list) {
+      const l = CML.PlutusDataList.new();
+      json2.list.forEach((v) => {
+        l.add(convert(v));
+      });
+      return CML.PlutusData.new_list(l);
+    } else if (json2.map && json2.map.length > 0 && typeof json2.map[0] === "object") {
+      const m = CML.PlutusMap.new();
+      json2.map.forEach(({ k, v }) => {
+        m.set(convert(k), convert(v));
+      });
+      return CML.PlutusData.new_map(m);
+    } else if (json2.map && typeof json2.map === "function") {
+      const l = CML.PlutusDataList.new();
+      Object.values(json2).forEach((value) => {
+        l.add(convert(value));
+      });
+      return CML.PlutusData.new_list(l);
+    } else if (!isNaN(json2.constructor)) {
+      const l = CML.PlutusDataList.new();
+      json2.fields.forEach((v) => {
+        l.add(convert(v));
+      });
+      const bigInt = CML.BigInteger.from_str(
+        json2.constructor.toString()
+      ).as_u64();
+      return CML.PlutusData.new_constr_plutus_data(
+        CML.ConstrPlutusData.new(bigInt, l)
+      );
+    }
+    throw new Error("Unsupported type");
+  };
+  return convert(json).to_cbor_hex();
+}
+
+// src/scripts.ts
+import { Data } from "@lucid-evolution/plutus";
+import {
+  Application,
+  encodeUPLC,
+  parseUPLC,
+  UPLCConst,
+  UPLCProgram
+} from "@harmoniclabs/uplc";
+import { fromHex as fromHex2, toHex as toHex2 } from "@lucid-evolution/core-utils";
+import { decode as decode2 } from "cbor-x";
+import { dataFromCbor } from "@harmoniclabs/plutus-data";
+function validatorToAddress(network, validator, stakeCredential) {
+  const validatorHash = validatorToScriptHash(validator);
+  if (stakeCredential) {
+    return CML.BaseAddress.new(
+      networkToId(network),
+      CML.Credential.new_script(CML.ScriptHash.from_hex(validatorHash)),
+      stakeCredential.type === "Key" ? CML.Credential.new_pub_key(
+        CML.Ed25519KeyHash.from_hex(stakeCredential.hash)
+      ) : CML.Credential.new_script(
+        CML.ScriptHash.from_hex(stakeCredential.hash)
+      )
+    ).to_address().to_bech32(void 0);
+  } else {
+    return CML.EnterpriseAddress.new(
+      networkToId(network),
+      CML.Credential.new_script(CML.ScriptHash.from_hex(validatorHash))
+    ).to_address().to_bech32(void 0);
+  }
+}
+function validatorToScriptHash(validator) {
+  switch (validator.type) {
+    case "Native":
+      return CML.NativeScript.from_cbor_hex(validator.script).hash().to_hex();
+    case "PlutusV1":
+      return CML.PlutusScript.from_v1(
+        CML.PlutusV1Script.from_cbor_hex(
+          applyDoubleCborEncoding(validator.script)
+        )
+      ).hash().to_hex();
+    case "PlutusV2":
+      return CML.PlutusScript.from_v2(
+        CML.PlutusV2Script.from_cbor_hex(
+          applyDoubleCborEncoding(validator.script)
+        )
+      ).hash().to_hex();
+    case "PlutusV3":
+      return CML.PlutusScript.from_v3(
+        CML.PlutusV3Script.from_cbor_hex(
+          applyDoubleCborEncoding(validator.script)
+        )
+      ).hash().to_hex();
+    default:
+      throw new Error("No variant matched");
+  }
+}
+function toScriptRef(script) {
+  switch (script.type) {
+    case "Native":
+      return CML.Script.new_native(
+        CML.NativeScript.from_cbor_hex(script.script)
+      );
+    case "PlutusV1":
+      return CML.Script.new_plutus_v1(
+        CML.PlutusV1Script.from_cbor_hex(
+          applyDoubleCborEncoding(script.script)
+        )
+      );
+    case "PlutusV2":
+      return CML.Script.new_plutus_v2(
+        CML.PlutusV2Script.from_cbor_hex(
+          applyDoubleCborEncoding(script.script)
+        )
+      );
+    case "PlutusV3":
+      return CML.Script.new_plutus_v3(
+        CML.PlutusV3Script.from_cbor_hex(
+          applyDoubleCborEncoding(script.script)
+        )
+      );
+    default:
+      throw new Error("No variant matched.");
+  }
+}
+function fromScriptRef(scriptRef) {
+  const kind = scriptRef.kind();
+  switch (kind) {
+    case 0:
+      return {
+        type: "Native",
+        script: scriptRef.as_native().to_cbor_hex()
+      };
+    case 1:
+      return {
+        type: "PlutusV1",
+        script: scriptRef.as_plutus_v1().to_cbor_hex()
+      };
+    case 2:
+      return {
+        type: "PlutusV2",
+        script: scriptRef.as_plutus_v2().to_cbor_hex()
+      };
+    case 3:
+      return {
+        type: "PlutusV3",
+        script: scriptRef.as_plutus_v3().to_cbor_hex()
+      };
+    default:
+      throw new Error("No variant matched.");
+  }
+}
+function mintingPolicyToId(mintingPolicy) {
+  return validatorToScriptHash(mintingPolicy);
+}
+function applyParamsToScript(plutusScript, params, type) {
+  const program = parseUPLC(
+    decode2(decode2(fromHex2(applyDoubleCborEncoding(plutusScript)))),
+    "flat"
+  );
+  const parameters = type ? Data.castTo(params, type) : params;
+  const appliedProgram = parameters.reduce((body, currentParameter) => {
+    const data = UPLCConst.data(dataFromCbor(Data.to(currentParameter)));
+    const appliedParameter = new Application(body, data);
+    return appliedParameter;
+  }, program.body);
+  return applyDoubleCborEncoding(
+    toHex2(
+      encodeUPLC(new UPLCProgram(program.version, appliedProgram)).toBuffer().buffer
+    )
+  );
+}
+
+// src/address.ts
+function addressFromHexOrBech32(address) {
+  try {
+    return CML.Address.from_hex(address);
+  } catch (_e) {
+    try {
+      return CML.Address.from_bech32(address);
+    } catch (_e2) {
+      throw new Error("Could not deserialize address.");
+    }
+  }
+}
+function credentialToRewardAddress(network, stakeCredential) {
+  return CML.RewardAddress.new(
+    networkToId(network),
+    stakeCredential.type === "Key" ? CML.Credential.new_pub_key(
+      CML.Ed25519KeyHash.from_hex(stakeCredential.hash)
+    ) : CML.Credential.new_script(
+      CML.ScriptHash.from_hex(stakeCredential.hash)
+    )
+  ).to_address().to_bech32(void 0);
+}
+function validatorToRewardAddress(network, validator) {
+  const validatorHash = validatorToScriptHash(validator);
+  return CML.RewardAddress.new(
+    networkToId(network),
+    CML.Credential.new_script(CML.ScriptHash.from_hex(validatorHash))
+  ).to_address().to_bech32(void 0);
+}
+function getAddressDetails(address) {
+  try {
+    const parsedAddress = CML.BaseAddress.from_address(
+      addressFromHexOrBech32(address)
+    );
+    const paymentCredential = parsedAddress.payment().kind() === 0 ? {
+      type: "Key",
+      hash: parsedAddress.payment().as_pub_key().to_hex()
+    } : {
+      type: "Script",
+      hash: parsedAddress.payment().as_script().to_hex()
+    };
+    const stakeCredential = parsedAddress.stake().kind() === 0 ? {
+      type: "Key",
+      hash: parsedAddress.stake().as_pub_key().to_hex()
+    } : {
+      type: "Script",
+      hash: parsedAddress.stake().as_script().to_hex()
+    };
+    return {
+      type: "Base",
+      networkId: parsedAddress.to_address().network_id(),
+      address: {
+        bech32: parsedAddress.to_address().to_bech32(void 0),
+        hex: parsedAddress.to_address().to_hex()
+      },
+      paymentCredential,
+      stakeCredential
+    };
+  } catch (_e) {
+  }
+  try {
+    const parsedAddress = CML.EnterpriseAddress.from_address(
+      addressFromHexOrBech32(address)
+    );
+    const paymentCredential = parsedAddress.payment().kind() === 0 ? {
+      type: "Key",
+      hash: parsedAddress.payment().as_pub_key().to_hex()
+    } : {
+      type: "Script",
+      hash: parsedAddress.payment().as_script().to_hex()
+    };
+    return {
+      type: "Enterprise",
+      networkId: parsedAddress.to_address().network_id(),
+      address: {
+        bech32: parsedAddress.to_address().to_bech32(void 0),
+        hex: parsedAddress.to_address().to_hex()
+      },
+      paymentCredential
+    };
+  } catch (_e) {
+  }
+  try {
+    const parsedAddress = CML.PointerAddress.from_address(
+      addressFromHexOrBech32(address)
+    );
+    const paymentCredential = parsedAddress?.payment().kind() === 0 ? {
+      type: "Key",
+      hash: parsedAddress.payment().as_pub_key().to_hex()
+    } : {
+      type: "Script",
+      hash: parsedAddress.payment().as_script().to_hex()
+    };
+    return {
+      type: "Pointer",
+      networkId: parsedAddress.to_address().network_id(),
+      address: {
+        bech32: parsedAddress.to_address().to_bech32(void 0),
+        hex: parsedAddress.to_address().to_hex()
+      },
+      paymentCredential
+    };
+  } catch (_e) {
+  }
+  try {
+    const parsedAddress = CML.RewardAddress.from_address(
+      addressFromHexOrBech32(address)
+    );
+    const stakeCredential = parsedAddress.payment().kind() === 0 ? {
+      type: "Key",
+      hash: parsedAddress.payment().as_pub_key().to_hex()
+    } : {
+      type: "Script",
+      hash: parsedAddress.payment().as_script().to_hex()
+    };
+    return {
+      type: "Reward",
+      networkId: parsedAddress.to_address().network_id(),
+      address: {
+        bech32: parsedAddress.to_address().to_bech32(void 0),
+        hex: parsedAddress.to_address().to_hex()
+      },
+      stakeCredential
+    };
+  } catch (_e) {
+  }
+  try {
+    const parsedAddress = ((address2) => {
+      try {
+        return CML.ByronAddress.from_cbor_hex(address2);
+      } catch (_e) {
+        try {
+          return CML.ByronAddress.from_base58(address2);
+        } catch (_e2) {
+          throw new Error("Could not deserialize address.");
+        }
+      }
+    })(address);
+    return {
+      type: "Byron",
+      networkId: parsedAddress.content().network_id(),
+      address: {
+        bech32: "",
+        hex: parsedAddress.to_address().to_hex()
+      }
+    };
+  } catch (_e) {
+  }
+  throw new Error("No address type matched for: " + address);
+}
+
+// src/cost_model.ts
+function createCostModels(costModels) {
+  const costmodel = {
+    0: [],
+    1: [],
+    2: []
+  };
+  for (const cost of Object.values(costModels.PlutusV1)) {
+    costmodel[0]?.push(cost);
+  }
+  for (const cost of Object.values(costModels.PlutusV2)) {
+    costmodel[1]?.push(cost);
+  }
+  for (const cost of Object.values(costModels.PlutusV3)) {
+    costmodel[2]?.push(cost);
+  }
+  return CML.CostModels.from_json(JSON.stringify(costmodel));
+}
+var PROTOCOL_PARAMETERS_DEFAULT = {
+  minFeeA: 44,
+  minFeeB: 155381,
+  maxTxSize: 16384,
+  maxValSize: 5e3,
+  keyDeposit: 2000000n,
+  poolDeposit: 500000000n,
+  drepDeposit: 500000000n,
+  govActionDeposit: 100000000000n,
+  priceMem: 0.0577,
+  priceStep: 721e-7,
+  maxTxExMem: 14000000n,
+  maxTxExSteps: 10000000000n,
+  coinsPerUtxoByte: 4310n,
+  collateralPercentage: 150,
+  maxCollateralInputs: 3,
+  minFeeRefScriptCostPerByte: 15,
+  costModels: {
+    PlutusV1: {
+      "0": 100788,
+      "1": 420,
+      "2": 1,
+      "3": 1,
+      "4": 1e3,
+      "5": 173,
+      "6": 0,
+      "7": 1,
+      "8": 1e3,
+      "9": 59957,
+      "10": 4,
+      "11": 1,
+      "12": 11183,
+      "13": 32,
+      "14": 201305,
+      "15": 8356,
+      "16": 4,
+      "17": 16e3,
+      "18": 100,
+      "19": 16e3,
+      "20": 100,
+      "21": 16e3,
+      "22": 100,
+      "23": 16e3,
+      "24": 100,
+      "25": 16e3,
+      "26": 100,
+      "27": 16e3,
+      "28": 100,
+      "29": 100,
+      "30": 100,
+      "31": 16e3,
+      "32": 100,
+      "33": 94375,
+      "34": 32,
+      "35": 132994,
+      "36": 32,
+      "37": 61462,
+      "38": 4,
+      "39": 72010,
+      "40": 178,
+      "41": 0,
+      "42": 1,
+      "43": 22151,
+      "44": 32,
+      "45": 91189,
+      "46": 769,
+      "47": 4,
+      "48": 2,
+      "49": 85848,
+      "50": 228465,
+      "51": 122,
+      "52": 0,
+      "53": 1,
+      "54": 1,
+      "55": 1e3,
+      "56": 42921,
+      "57": 4,
+      "58": 2,
+      "59": 24548,
+      "60": 29498,
+      "61": 38,
+      "62": 1,
+      "63": 898148,
+      "64": 27279,
+      "65": 1,
+      "66": 51775,
+      "67": 558,
+      "68": 1,
+      "69": 39184,
+      "70": 1e3,
+      "71": 60594,
+      "72": 1,
+      "73": 141895,
+      "74": 32,
+      "75": 83150,
+      "76": 32,
+      "77": 15299,
+      "78": 32,
+      "79": 76049,
+      "80": 1,
+      "81": 13169,
+      "82": 4,
+      "83": 22100,
+      "84": 10,
+      "85": 28999,
+      "86": 74,
+      "87": 1,
+      "88": 28999,
+      "89": 74,
+      "90": 1,
+      "91": 43285,
+      "92": 552,
+      "93": 1,
+      "94": 44749,
+      "95": 541,
+      "96": 1,
+      "97": 33852,
+      "98": 32,
+      "99": 68246,
+      "100": 32,
+      "101": 72362,
+      "102": 32,
+      "103": 7243,
+      "104": 32,
+      "105": 7391,
+      "106": 32,
+      "107": 11546,
+      "108": 32,
+      "109": 85848,
+      "110": 228465,
+      "111": 122,
+      "112": 0,
+      "113": 1,
+      "114": 1,
+      "115": 90434,
+      "116": 519,
+      "117": 0,
+      "118": 1,
+      "119": 74433,
+      "120": 32,
+      "121": 85848,
+      "122": 228465,
+      "123": 122,
+      "124": 0,
+      "125": 1,
+      "126": 1,
+      "127": 85848,
+      "128": 228465,
+      "129": 122,
+      "130": 0,
+      "131": 1,
+      "132": 1,
+      "133": 270652,
+      "134": 22588,
+      "135": 4,
+      "136": 1457325,
+      "137": 64566,
+      "138": 4,
+      "139": 20467,
+      "140": 1,
+      "141": 4,
+      "142": 0,
+      "143": 141992,
+      "144": 32,
+      "145": 100788,
+      "146": 420,
+      "147": 1,
+      "148": 1,
+      "149": 81663,
+      "150": 32,
+      "151": 59498,
+      "152": 32,
+      "153": 20142,
+      "154": 32,
+      "155": 24588,
+      "156": 32,
+      "157": 20744,
+      "158": 32,
+      "159": 25933,
+      "160": 32,
+      "161": 24623,
+      "162": 32,
+      "163": 53384111,
+      "164": 14333,
+      "165": 10
+    },
+    PlutusV2: {
+      "0": 100788,
+      "1": 420,
+      "2": 1,
+      "3": 1,
+      "4": 1e3,
+      "5": 173,
+      "6": 0,
+      "7": 1,
+      "8": 1e3,
+      "9": 59957,
+      "10": 4,
+      "11": 1,
+      "12": 11183,
+      "13": 32,
+      "14": 201305,
+      "15": 8356,
+      "16": 4,
+      "17": 16e3,
+      "18": 100,
+      "19": 16e3,
+      "20": 100,
+      "21": 16e3,
+      "22": 100,
+      "23": 16e3,
+      "24": 100,
+      "25": 16e3,
+      "26": 100,
+      "27": 16e3,
+      "28": 100,
+      "29": 100,
+      "30": 100,
+      "31": 16e3,
+      "32": 100,
+      "33": 94375,
+      "34": 32,
+      "35": 132994,
+      "36": 32,
+      "37": 61462,
+      "38": 4,
+      "39": 72010,
+      "40": 178,
+      "41": 0,
+      "42": 1,
+      "43": 22151,
+      "44": 32,
+      "45": 91189,
+      "46": 769,
+      "47": 4,
+      "48": 2,
+      "49": 85848,
+      "50": 228465,
+      "51": 122,
+      "52": 0,
+      "53": 1,
+      "54": 1,
+      "55": 1e3,
+      "56": 42921,
+      "57": 4,
+      "58": 2,
+      "59": 24548,
+      "60": 29498,
+      "61": 38,
+      "62": 1,
+      "63": 898148,
+      "64": 27279,
+      "65": 1,
+      "66": 51775,
+      "67": 558,
+      "68": 1,
+      "69": 39184,
+      "70": 1e3,
+      "71": 60594,
+      "72": 1,
+      "73": 141895,
+      "74": 32,
+      "75": 83150,
+      "76": 32,
+      "77": 15299,
+      "78": 32,
+      "79": 76049,
+      "80": 1,
+      "81": 13169,
+      "82": 4,
+      "83": 22100,
+      "84": 10,
+      "85": 28999,
+      "86": 74,
+      "87": 1,
+      "88": 28999,
+      "89": 74,
+      "90": 1,
+      "91": 43285,
+      "92": 552,
+      "93": 1,
+      "94": 44749,
+      "95": 541,
+      "96": 1,
+      "97": 33852,
+      "98": 32,
+      "99": 68246,
+      "100": 32,
+      "101": 72362,
+      "102": 32,
+      "103": 7243,
+      "104": 32,
+      "105": 7391,
+      "106": 32,
+      "107": 11546,
+      "108": 32,
+      "109": 85848,
+      "110": 228465,
+      "111": 122,
+      "112": 0,
+      "113": 1,
+      "114": 1,
+      "115": 90434,
+      "116": 519,
+      "117": 0,
+      "118": 1,
+      "119": 74433,
+      "120": 32,
+      "121": 85848,
+      "122": 228465,
+      "123": 122,
+      "124": 0,
+      "125": 1,
+      "126": 1,
+      "127": 85848,
+      "128": 228465,
+      "129": 122,
+      "130": 0,
+      "131": 1,
+      "132": 1,
+      "133": 955506,
+      "134": 213312,
+      "135": 0,
+      "136": 2,
+      "137": 270652,
+      "138": 22588,
+      "139": 4,
+      "140": 1457325,
+      "141": 64566,
+      "142": 4,
+      "143": 20467,
+      "144": 1,
+      "145": 4,
+      "146": 0,
+      "147": 141992,
+      "148": 32,
+      "149": 100788,
+      "150": 420,
+      "151": 1,
+      "152": 1,
+      "153": 81663,
+      "154": 32,
+      "155": 59498,
+      "156": 32,
+      "157": 20142,
+      "158": 32,
+      "159": 24588,
+      "160": 32,
+      "161": 20744,
+      "162": 32,
+      "163": 25933,
+      "164": 32,
+      "165": 24623,
+      "166": 32,
+      "167": 43053543,
+      "168": 10,
+      "169": 53384111,
+      "170": 14333,
+      "171": 10,
+      "172": 43574283,
+      "173": 26308,
+      "174": 10
+    },
+    PlutusV3: {
+      "0": 100788,
+      "1": 420,
+      "2": 1,
+      "3": 1,
+      "4": 1e3,
+      "5": 173,
+      "6": 0,
+      "7": 1,
+      "8": 1e3,
+      "9": 59957,
+      "10": 4,
+      "11": 1,
+      "12": 11183,
+      "13": 32,
+      "14": 201305,
+      "15": 8356,
+      "16": 4,
+      "17": 16e3,
+      "18": 100,
+      "19": 16e3,
+      "20": 100,
+      "21": 16e3,
+      "22": 100,
+      "23": 16e3,
+      "24": 100,
+      "25": 16e3,
+      "26": 100,
+      "27": 16e3,
+      "28": 100,
+      "29": 100,
+      "30": 100,
+      "31": 16e3,
+      "32": 100,
+      "33": 94375,
+      "34": 32,
+      "35": 132994,
+      "36": 32,
+      "37": 61462,
+      "38": 4,
+      "39": 72010,
+      "40": 178,
+      "41": 0,
+      "42": 1,
+      "43": 22151,
+      "44": 32,
+      "45": 91189,
+      "46": 769,
+      "47": 4,
+      "48": 2,
+      "49": 85848,
+      "50": 123203,
+      "51": 7305,
+      "52": -900,
+      "53": 1716,
+      "54": 549,
+      "55": 57,
+      "56": 85848,
+      "57": 0,
+      "58": 1,
+      "59": 1,
+      "60": 1e3,
+      "61": 42921,
+      "62": 4,
+      "63": 2,
+      "64": 24548,
+      "65": 29498,
+      "66": 38,
+      "67": 1,
+      "68": 898148,
+      "69": 27279,
+      "70": 1,
+      "71": 51775,
+      "72": 558,
+      "73": 1,
+      "74": 39184,
+      "75": 1e3,
+      "76": 60594,
+      "77": 1,
+      "78": 141895,
+      "79": 32,
+      "80": 83150,
+      "81": 32,
+      "82": 15299,
+      "83": 32,
+      "84": 76049,
+      "85": 1,
+      "86": 13169,
+      "87": 4,
+      "88": 22100,
+      "89": 10,
+      "90": 28999,
+      "91": 74,
+      "92": 1,
+      "93": 28999,
+      "94": 74,
+      "95": 1,
+      "96": 43285,
+      "97": 552,
+      "98": 1,
+      "99": 44749,
+      "100": 541,
+      "101": 1,
+      "102": 33852,
+      "103": 32,
+      "104": 68246,
+      "105": 32,
+      "106": 72362,
+      "107": 32,
+      "108": 7243,
+      "109": 32,
+      "110": 7391,
+      "111": 32,
+      "112": 11546,
+      "113": 32,
+      "114": 85848,
+      "115": 123203,
+      "116": 7305,
+      "117": -900,
+      "118": 1716,
+      "119": 549,
+      "120": 57,
+      "121": 85848,
+      "122": 0,
+      "123": 1,
+      "124": 90434,
+      "125": 519,
+      "126": 0,
+      "127": 1,
+      "128": 74433,
+      "129": 32,
+      "130": 85848,
+      "131": 123203,
+      "132": 7305,
+      "133": -900,
+      "134": 1716,
+      "135": 549,
+      "136": 57,
+      "137": 85848,
+      "138": 0,
+      "139": 1,
+      "140": 1,
+      "141": 85848,
+      "142": 123203,
+      "143": 7305,
+      "144": -900,
+      "145": 1716,
+      "146": 549,
+      "147": 57,
+      "148": 85848,
+      "149": 0,
+      "150": 1,
+      "151": 955506,
+      "152": 213312,
+      "153": 0,
+      "154": 2,
+      "155": 270652,
+      "156": 22588,
+      "157": 4,
+      "158": 1457325,
+      "159": 64566,
+      "160": 4,
+      "161": 20467,
+      "162": 1,
+      "163": 4,
+      "164": 0,
+      "165": 141992,
+      "166": 32,
+      "167": 100788,
+      "168": 420,
+      "169": 1,
+      "170": 1,
+      "171": 81663,
+      "172": 32,
+      "173": 59498,
+      "174": 32,
+      "175": 20142,
+      "176": 32,
+      "177": 24588,
+      "178": 32,
+      "179": 20744,
+      "180": 32,
+      "181": 25933,
+      "182": 32,
+      "183": 24623,
+      "184": 32,
+      "185": 43053543,
+      "186": 10,
+      "187": 53384111,
+      "188": 14333,
+      "189": 10,
+      "190": 43574283,
+      "191": 26308,
+      "192": 10,
+      "193": 16e3,
+      "194": 100,
+      "195": 16e3,
+      "196": 100,
+      "197": 962335,
+      "198": 18,
+      "199": 2780678,
+      "200": 6,
+      "201": 442008,
+      "202": 1,
+      "203": 52538055,
+      "204": 3756,
+      "205": 18,
+      "206": 267929,
+      "207": 18,
+      "208": 76433006,
+      "209": 8868,
+      "210": 18,
+      "211": 52948122,
+      "212": 18,
+      "213": 1995836,
+      "214": 36,
+      "215": 3227919,
+      "216": 12,
+      "217": 901022,
+      "218": 1,
+      "219": 166917843,
+      "220": 4307,
+      "221": 36,
+      "222": 284546,
+      "223": 36,
+      "224": 158221314,
+      "225": 26549,
+      "226": 36,
+      "227": 74698472,
+      "228": 36,
+      "229": 333849714,
+      "230": 1,
+      "231": 254006273,
+      "232": 72,
+      "233": 2174038,
+      "234": 72,
+      "235": 2261318,
+      "236": 64571,
+      "237": 4,
+      "238": 207616,
+      "239": 8310,
+      "240": 4,
+      "241": 1293828,
+      "242": 28716,
+      "243": 63,
+      "244": 0,
+      "245": 1,
+      "246": 1006041,
+      "247": 43623,
+      "248": 251,
+      "249": 0,
+      "250": 1,
+      "251": 100181,
+      "252": 726,
+      "253": 719,
+      "254": 0,
+      "255": 1,
+      "256": 100181,
+      "257": 726,
+      "258": 719,
+      "259": 0,
+      "260": 1,
+      "261": 100181,
+      "262": 726,
+      "263": 719,
+      "264": 0,
+      "265": 1,
+      "266": 107878,
+      "267": 680,
+      "268": 0,
+      "269": 1,
+      "270": 95336,
+      "271": 1,
+      "272": 281145,
+      "273": 18848,
+      "274": 0,
+      "275": 1,
+      "276": 180194,
+      "277": 159,
+      "278": 1,
+      "279": 1,
+      "280": 158519,
+      "281": 8942,
+      "282": 0,
+      "283": 1,
+      "284": 159378,
+      "285": 8813,
+      "286": 0,
+      "287": 1,
+      "288": 107490,
+      "289": 3298,
+      "290": 1,
+      "291": 106057,
+      "292": 655,
+      "293": 1,
+      "294": 1964219,
+      "295": 24520,
+      "296": 3
+    }
+  }
+};
+
+// src/credential.ts
+function credentialToAddress(network, paymentCredential, stakeCredential) {
+  if (stakeCredential) {
+    return CML.BaseAddress.new(
+      networkToId(network),
+      paymentCredential.type === "Key" ? CML.Credential.new_pub_key(
+        CML.Ed25519KeyHash.from_hex(paymentCredential.hash)
+      ) : CML.Credential.new_script(
+        CML.ScriptHash.from_hex(paymentCredential.hash)
+      ),
+      stakeCredential.type === "Key" ? CML.Credential.new_pub_key(
+        CML.Ed25519KeyHash.from_hex(stakeCredential.hash)
+      ) : CML.Credential.new_script(
+        CML.ScriptHash.from_hex(stakeCredential.hash)
+      )
+    ).to_address().to_bech32(void 0);
+  } else {
+    return CML.EnterpriseAddress.new(
+      networkToId(network),
+      paymentCredential.type === "Key" ? CML.Credential.new_pub_key(
+        CML.Ed25519KeyHash.from_hex(paymentCredential.hash)
+      ) : CML.Credential.new_script(
+        CML.ScriptHash.from_hex(paymentCredential.hash)
+      )
+    ).to_address().to_bech32(void 0);
+  }
+}
+function scriptHashToCredential(scriptHash) {
+  return {
+    type: "Script",
+    hash: scriptHash
+  };
+}
+function keyHashToCredential(keyHash) {
+  return {
+    type: "Key",
+    hash: keyHash
+  };
+}
+function paymentCredentialOf(address) {
+  const { paymentCredential } = getAddressDetails(address);
+  if (!paymentCredential) {
+    throw new Error(
+      "The specified address does not contain a payment credential."
+    );
+  }
+  return paymentCredential;
+}
+function stakeCredentialOf(rewardAddress) {
+  const { stakeCredential } = getAddressDetails(rewardAddress);
+  if (!stakeCredential) {
+    throw new Error(
+      "The specified address does not contain a stake credential."
+    );
+  }
+  return stakeCredential;
+}
+
+// src/datum.ts
+function datumToHash(datum) {
+  return CML.hash_plutus_data(CML.PlutusData.from_cbor_hex(datum)).to_hex();
+}
+
+// src/keys.ts
+import { generateMnemonic } from "bip39";
+function generatePrivateKey() {
+  return CML.PrivateKey.generate_ed25519().to_bech32();
+}
+function generateSeedPhrase() {
+  return generateMnemonic(256);
+}
+function toPublicKey(privateKey) {
+  return CML.PrivateKey.from_bech32(privateKey).to_public().to_bech32();
+}
+
+// src/label.ts
+import { fromHex as fromHex3 } from "@lucid-evolution/core-utils";
+import { crc8 } from "@lucid-evolution/crc8";
+function toLabel(num) {
+  if (num < 0 || num > 65535) {
+    throw new Error(
+      `Label ${num} out of range: min label 1 - max label 65535.`
+    );
+  }
+  const numHex = num.toString(16).padStart(4, "0");
+  return "0" + numHex + checksum(numHex) + "0";
+}
+function fromLabel(label) {
+  if (label.length !== 8 || !(label[0] === "0" && label[7] === "0")) {
+    return null;
+  }
+  const numHex = label.slice(1, 5);
+  const num = parseInt(numHex, 16);
+  const check = label.slice(5, 7);
+  return check === checksum(numHex) ? num : null;
+}
+function checksum(num) {
+  return crc8(fromHex3(num)).toString(16).padStart(2, "0");
+}
+
+// src/time.ts
+import {
+  SLOT_CONFIG_NETWORK,
+  slotToBeginUnixTime,
+  unixTimeToEnclosingSlot
+} from "@lucid-evolution/plutus";
+function unixTimeToSlot(network, unixTime) {
+  return unixTimeToEnclosingSlot(unixTime, SLOT_CONFIG_NETWORK[network]);
+}
+function slotToUnixTime(network, slot) {
+  return slotToBeginUnixTime(slot, SLOT_CONFIG_NETWORK[network]);
+}
+
+// src/value.ts
+import { fromHex as fromHex4, toHex as toHex3 } from "@lucid-evolution/core-utils";
+import { pipe } from "effect";
+function valueToAssets(value) {
+  const assets = {};
+  assets["lovelace"] = value.coin();
+  if (value.has_multiassets()) {
+    const ma = value.multi_asset();
+    const multiAssets = ma.keys();
+    for (let j = 0; j < multiAssets.len(); j++) {
+      const policy = multiAssets.get(j);
+      const policyAssets = ma.get_assets(policy);
+      const assetNames = policyAssets.keys();
+      for (let k = 0; k < assetNames.len(); k++) {
+        const policyAsset = assetNames.get(k);
+        const quantity = policyAssets.get(policyAsset);
+        const unit = policy.to_hex() + policyAsset.to_js_value();
+        assets[unit] = quantity;
+      }
+    }
+  }
+  return assets;
+}
+function assetsToValue(assets) {
+  const multiAsset = CML.MultiAsset.new();
+  const lovelace = assets["lovelace"] ? BigInt(assets["lovelace"]) : 0n;
+  const units = Object.keys(assets);
+  const policies = Array.from(
+    new Set(
+      units.filter((unit) => unit !== "lovelace").map((unit) => unit.slice(0, 56))
+    )
+  );
+  for (const policy of policies) {
+    const policyUnits = units.filter((unit) => unit.slice(0, 56) === policy);
+    const assetsValue = CML.MapAssetNameToCoin.new();
+    for (const unit of policyUnits) {
+      assetsValue.insert(
+        CML.AssetName.from_hex(unit.slice(56)),
+        BigInt(assets[unit])
+      );
+    }
+    multiAsset.insert_assets(CML.ScriptHash.from_hex(policy), assetsValue);
+  }
+  return CML.Value.new(lovelace, multiAsset);
+}
+function fromUnit(unit) {
+  const policyId = unit.slice(0, 56);
+  const assetName = unit.slice(56) || null;
+  const label = fromLabel(unit.slice(56, 64));
+  const name = (() => {
+    const hexName = Number.isInteger(label) ? unit.slice(64) : unit.slice(56);
+    return hexName || null;
+  })();
+  return { policyId, assetName, name, label };
+}
+function toUnit(policyId, name, label) {
+  const hexLabel = Number.isInteger(label) ? toLabel(label) : "";
+  const n = name ? name : "";
+  if ((n + hexLabel).length > 64) {
+    throw new Error("Asset name size exceeds 32 bytes.");
+  }
+  if (policyId.length !== 56) {
+    throw new Error(`Policy id invalid: ${policyId}.`);
+  }
+  return policyId + hexLabel + n;
+}
+function addAssets(...assets) {
+  return assets.reduce((a, b) => {
+    for (const k in b) {
+      if (Object.hasOwn(b, k)) {
+        const sum = (a[k] || 0n) + b[k];
+        if (sum === 0n) {
+          delete a[k];
+        } else {
+          a[k] = sum;
+        }
+      }
+    }
+    return a;
+  }, {});
+}
+async function getUniqueTokenName(utxo) {
+  const id = fromHex4(utxo.txHash);
+  const data = new Uint8Array([utxo.outputIndex, ...id]);
+  const hash = new Uint8Array(await crypto.subtle.digest("SHA3-256", data));
+  return toHex3(hash);
+}
+var sortCanonical = (assets) => pipe(
+  Object.entries(assets).sort(([aUnit], [bUnit]) => {
+    const a = fromUnit(aUnit);
+    const b = fromUnit(bUnit);
+    if (a.policyId.length !== b.policyId.length)
+      return a.policyId.length - b.policyId.length;
+    if (a.policyId === b.policyId) {
+      const aAssetName = a.assetName || "";
+      const bAssetName = b.assetName || "";
+      if (aAssetName.length !== bAssetName.length)
+        return aAssetName.length - bAssetName.length;
+      return aAssetName.localeCompare(bAssetName);
+    }
+    return a.policyId.localeCompare(b.policyId);
+  }),
+  Object.fromEntries
+);
+
+// src/utxo.ts
+var utxoToTransactionOutput = (utxo) => {
+  return buildOutput(utxo).with_value(assetsToValue(utxo.assets)).build().output();
+};
+var utxoToTransactionInput = (utxo) => {
+  return CML.TransactionInput.new(
+    CML.TransactionHash.from_hex(utxo.txHash),
+    BigInt(utxo.outputIndex)
+  );
+};
+var utxoToCore = (utxo) => {
+  const out = utxoToTransactionOutput(utxo);
+  const utxoCore = CML.TransactionUnspentOutput.new(
+    utxoToTransactionInput(utxo),
+    out
+  );
+  return utxoCore;
+};
+function utxosToCores(utxos) {
+  const result = [];
+  for (const utxo of utxos) {
+    result.push(utxoToCore(utxo));
+  }
+  return result;
+}
+function coreToUtxo(coreUtxo) {
+  const utxo = {
+    ...coreToOutRef(coreUtxo.input()),
+    ...coreToTxOutput(coreUtxo.output())
+  };
+  return utxo;
+}
+function coresToUtxos(utxos) {
+  const result = [];
+  for (let i = 0; i < utxos.length; i++) {
+    result.push(coreToUtxo(utxos[i]));
+  }
+  return result;
+}
+function coreToOutRef(input) {
+  return {
+    txHash: input.transaction_id().to_hex(),
+    outputIndex: parseInt(input.index().toString())
+  };
+}
+function coresToOutRefs(inputs) {
+  const result = [];
+  for (let i = 0; i < inputs.length; i++) {
+    result.push(coreToOutRef(inputs[i]));
+  }
+  return result;
+}
+function coreToTxOutput(output) {
+  return {
+    assets: valueToAssets(output.amount()),
+    address: output.address().to_bech32(void 0),
+    datumHash: output.datum()?.as_hash()?.to_hex(),
+    datum: output.datum()?.as_datum()?.to_cbor_hex(),
+    scriptRef: output.script_ref() && fromScriptRef(output.script_ref())
+  };
+}
+function coresToTxOutputs(outputs) {
+  let result = [];
+  for (let i = 0; i < outputs.length; i++) {
+    result.push(coreToTxOutput(outputs[i]));
+  }
+  return result;
+}
+var selectUTxOs = (utxos, totalAssets, includeUTxOsWithScriptRef = false) => {
+  const selectedUtxos = [];
+  let isSelected = false;
+  const assetsRequired = new Map(Object.entries(totalAssets));
+  for (const utxo of utxos) {
+    if (!includeUTxOsWithScriptRef && utxo.scriptRef) continue;
+    isSelected = false;
+    for (const [unit, amount] of assetsRequired) {
+      if (Object.hasOwn(utxo.assets, unit)) {
+        const utxoAmount = utxo.assets[unit];
+        if (utxoAmount >= amount) {
+          assetsRequired.delete(unit);
+        } else {
+          assetsRequired.set(unit, amount - utxoAmount);
+        }
+        isSelected = true;
+      }
+    }
+    if (isSelected) {
+      selectedUtxos.push(utxo);
+    }
+    if (assetsRequired.size == 0) {
+      break;
+    }
+  }
+  if (assetsRequired.size > 0) return [];
+  return selectedUtxos;
+};
+var sortUTxOs = (utxos, order = "LargestFirst") => {
+  switch (order) {
+    case "LargestFirst":
+      return [...utxos].sort(largestFirst);
+    case "SmallestFirst":
+      return [...utxos].sort(smallestFirst);
+    case "Canonical":
+      return [...utxos].sort(canonical);
+    case "Collateral":
+      return [...utxos].sort(collateralOrder);
+  }
+};
+var collateralOrder = (a, b) => {
+  const lovelaceA = Number(a.assets["lovelace"]);
+  const lovelaceB = Number(b.assets["lovelace"]);
+  const assetsA = Object.keys(a.assets).length;
+  const assetsB = Object.keys(b.assets).length;
+  if (assetsA === 0 && assetsB > 0) return -1;
+  if (assetsB === 0 && assetsA > 0) return 1;
+  return lovelaceB - lovelaceA;
+};
+var largestFirst = (a, b) => {
+  const lovelaceA = Number(a.assets["lovelace"]);
+  const lovelaceB = Number(b.assets["lovelace"]);
+  if (lovelaceA === lovelaceB) {
+    return Object.keys(a.assets).length - Object.keys(b.assets).length;
+  }
+  return -1 * (lovelaceA - lovelaceB);
+};
+var smallestFirst = (a, b) => {
+  const lovelaceA = Number(a.assets["lovelace"]);
+  const lovelaceB = Number(b.assets["lovelace"]);
+  if (lovelaceA == lovelaceB) {
+    return Object.keys(a.assets).length - Object.keys(b.assets).length;
+  }
+  return lovelaceA - lovelaceB;
+};
+var canonical = (a, b) => {
+  if (a.txHash < b.txHash) {
+    return -1;
+  } else if (a.txHash > b.txHash) {
+    return 1;
+  } else {
+    return a.outputIndex - b.outputIndex;
+  }
+};
+var isEqualUTxO = (self, that) => self.txHash === that.txHash && self.outputIndex === that.outputIndex;
+function getInputIndices(indexInputs, allInputs, sorted = false) {
+  const sortedInputs = sorted ? allInputs : sortUTxOs(allInputs, "Canonical");
+  const indicesMap = /* @__PURE__ */ new Map();
+  sortedInputs.forEach((value, index) => {
+    indicesMap.set(value.txHash + value.outputIndex, BigInt(index));
+  });
+  return indexInputs.flatMap((value) => {
+    const index = indicesMap.get(value.txHash + value.outputIndex);
+    if (index !== void 0) return index;
+    else return [];
+  });
+}
+var calculateMinLovelaceFromUTxO = (coinsPerUtxoByte, utxo) => buildOutput(utxo).with_asset_and_min_required_coin(
+  assetsToValue(utxo.assets).multi_asset(),
+  coinsPerUtxoByte
+).build().output().amount().coin();
+var buildOutput = (utxo) => {
+  const builder = CML.TransactionOutputBuilder.new().with_address(
+    CML.Address.from_bech32(utxo.address)
+  );
+  return utxo.scriptRef ? buildDatum(utxo, builder).with_reference_script(toScriptRef(utxo.scriptRef)).next() : buildDatum(utxo, builder).next();
+};
+var buildDatum = (utxo, builder) => {
+  if (utxo.datumHash && utxo.datum)
+    return builder.with_communication_data(
+      CML.PlutusData.from_cbor_hex(utxo.datum)
+    );
+  if (utxo.datum)
+    return builder.with_data(
+      CML.DatumOption.new_datum(CML.PlutusData.from_cbor_hex(utxo.datum))
+    );
+  return builder;
+};
+
+// src/objects.ts
+var stringify = (data) => JSON.stringify(
+  data,
+  (key, value) => typeof value === "bigint" ? value.toString() + "n" : value,
+  2
+);
+
+// src/redeemer.ts
+var toCMLRedeemerTag = (tag) => {
+  switch (tag) {
+    case "spend":
+      return CML.RedeemerTag.Spend;
+    case "mint":
+      return CML.RedeemerTag.Mint;
+    case "publish":
+      return CML.RedeemerTag.Cert;
+    case "withdraw":
+      return CML.RedeemerTag.Reward;
+    case "vote":
+      return CML.RedeemerTag.Voting;
+    case "propose":
+      return CML.RedeemerTag.Proposing;
+    default:
+      throw new Error(`Exhaustive check failed: Unhandled case ${tag}`);
+  }
+};
+var fromCMLRedeemerTag = (tag) => {
+  switch (tag) {
+    case CML.RedeemerTag.Spend:
+      return "spend";
+    case CML.RedeemerTag.Mint:
+      return "mint";
+    case CML.RedeemerTag.Cert:
+      return "publish";
+    case CML.RedeemerTag.Reward:
+      return "withdraw";
+    case CML.RedeemerTag.Voting:
+      return "vote";
+    case CML.RedeemerTag.Proposing:
+      return "propose";
+    default:
+      throw new Error(`Exhaustive check failed: Unhandled case ${tag}`);
+  }
+};
+export {
+  CBOREncodingLevel,
+  PROTOCOL_PARAMETERS_DEFAULT,
+  addAssets,
+  addressFromHexOrBech32,
+  applyDoubleCborEncoding,
+  applyParamsToScript,
+  applySingleCborEncoding,
+  assetsToValue,
+  calculateMinLovelaceFromUTxO,
+  coreToOutRef,
+  coreToTxOutput,
+  coreToUtxo,
+  coresToOutRefs,
+  coresToTxOutputs,
+  coresToUtxos,
+  createCostModels,
+  credentialToAddress,
+  credentialToRewardAddress,
+  datumJsonToCbor,
+  datumToHash,
+  fromCMLRedeemerTag,
+  fromLabel,
+  fromScriptRef,
+  fromUnit,
+  generatePrivateKey,
+  generateSeedPhrase,
+  getAddressDetails,
+  getInputIndices,
+  getUniqueTokenName,
+  isEqualUTxO,
+  keyHashToCredential,
+  mintingPolicyToId,
+  networkToId,
+  parseCMLNative,
+  paymentCredentialOf,
+  scriptFromCMLNative,
+  scriptFromNative,
+  scriptHashToCredential,
+  selectUTxOs,
+  slotToUnixTime,
+  sortCanonical,
+  sortUTxOs,
+  stakeCredentialOf,
+  stringify,
+  toCMLNativeScript,
+  toCMLRedeemerTag,
+  toLabel,
+  toPublicKey,
+  toScriptRef,
+  toUnit,
+  unixTimeToSlot,
+  utxoToCore,
+  utxoToTransactionInput,
+  utxoToTransactionOutput,
+  utxosToCores,
+  validatorToAddress,
+  validatorToRewardAddress,
+  validatorToScriptHash,
+  valueToAssets
+};
